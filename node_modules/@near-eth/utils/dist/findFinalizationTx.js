"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFinalizationTxOnEthereum = exports.findFinalizationTxOnNear = exports.SearchError = void 0;
const ethers_1 = require("ethers");
const bs58_1 = __importDefault(require("bs58"));
class SearchError extends Error {
}
exports.SearchError = SearchError;
async function findFinalizationTxOnNear({ proof, connectorAccount, eventRelayerAccount, finalizationMethod, callIndexer }) {
    const query = `SELECT public.receipts.originated_from_transaction_hash, public.receipts.included_in_block_timestamp
    FROM public.receipts
    JOIN public.action_receipt_actions
    ON public.action_receipt_actions.receipt_id = public.receipts.receipt_id
    WHERE (receipt_predecessor_account_id = '${eventRelayerAccount}'
      AND receipt_receiver_account_id = '${connectorAccount}'
      AND args ->> 'method_name' = '${finalizationMethod}'
      AND args ->> 'args_base64' = '${proof}'
    )`;
    // NOTE: Generally only 1 result is returned, but allow multiple in case finalization attempts are made.
    const results = await callIndexer(query);
    const transactions = results.map(tx => tx.originated_from_transaction_hash);
    const timestamps = results.map(tx => Number(tx.included_in_block_timestamp));
    return { transactions, timestamps };
}
exports.findFinalizationTxOnNear = findFinalizationTxOnNear;
async function proofAlreadyUsed(proofStorageIndex, connectorAddress, blockHeight, provider) {
    const proofIsUsed = await provider.getStorageAt(connectorAddress, proofStorageIndex, blockHeight);
    return Number(proofIsUsed) === 1;
}
async function findFinalizationTxOnEthereum({ usedProofPosition, proof, connectorAddress, connectorAbi, finalizationEvent, recipient, amount, provider }) {
    const usedProofsMappingPosition = '0'.repeat(63) + usedProofPosition;
    const usedProofsKey = bs58_1.default.decode(proof.outcome_proof.outcome.receipt_ids[0]).toString('hex');
    const proofStorageIndex = ethers_1.ethers.utils.keccak256('0x' + usedProofsKey + usedProofsMappingPosition);
    let maxBlock = await provider.getBlockNumber();
    let minBlock = 0;
    while (minBlock < maxBlock) {
        const middleBlock = Math.floor((minBlock + maxBlock) / 2);
        const finalized = await proofAlreadyUsed(proofStorageIndex, connectorAddress, middleBlock, provider);
        if (!finalized) {
            // middleBlock was mined before the transfer was finalized, so take next block as lower bound
            minBlock = middleBlock + 1;
        }
        else {
            maxBlock = middleBlock;
        }
    }
    const connectorContract = new ethers_1.ethers.Contract(connectorAddress, connectorAbi, provider);
    // NOTE: Depending on the connector, event args are in different order or not indexed, so query all and filter.
    const filter = connectorContract.filters[finalizationEvent]();
    const events = await connectorContract.queryFilter(filter, minBlock, minBlock);
    const transactions = events.filter(e => e.args.recipient.toLowerCase() === recipient.toLowerCase() && e.args.amount.toString() === amount).map(e => e.transactionHash);
    if (transactions.length === 0) {
        throw new SearchError(`Finalization tx on Ethereum not found for proof: ${JSON.stringify(proof)}`);
    }
    const block = await provider.getBlock(minBlock);
    return { transactions, block };
}
exports.findFinalizationTxOnEthereum = findFinalizationTxOnEthereum;
//# sourceMappingURL=findFinalizationTx.js.map