"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findNearProof = exports.findEthProof = void 0;
const lite_merkle_patricia_tree_1 = require("lite-merkle-patricia-tree");
// import Tree from 'merkle-patricia-tree'
// import { promisfy } from 'promisfy'
// @ts-expect-error
const eth_object_1 = require("eth-object");
const ethereumjs_util_1 = require("ethereumjs-util");
const serialize_1 = require("near-api-js/lib/utils/serialize");
const provider_1 = require("near-api-js/lib/providers/provider");
const ethers_1 = require("ethers");
const bs58_1 = __importDefault(require("bs58"));
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class BorshProof {
    constructor(proof) {
        Object.assign(this, proof);
    }
}
const proofBorshSchema = new Map([
    [BorshProof, {
            kind: 'struct',
            fields: [
                ['log_index', 'u64'],
                ['log_entry_data', ['u8']],
                ['receipt_index', 'u64'],
                ['receipt_data', ['u8']],
                ['header_data', ['u8']],
                ['proof', [['u8']]]
            ]
        }]
]);
// Compute proof that Locked event was fired in Ethereum. This proof can then
// be passed to the FungibleTokenFactory contract, which verifies the proof
// against a Prover contract.
async function findEthProof(eventName, txHash, address, abi, provider) {
    const contract = new ethers_1.ethers.Contract(address, abi, provider);
    const receipt = await provider.getTransactionReceipt(txHash);
    if (!receipt.status) {
        // When connecting via walletConnect, a random bug can happen where the receipt.status
        // is false event though we know it should be true.
        // https://github.com/near/rainbow-bridge-client/issues/12
        throw new Error(`Invalid Ethereum receipt status received from provider, please try again.
       If retrying doesn't solve this error, connecting a Metamask account may solve the issue`);
    }
    // const block = await provider.getBlock(receipt.blockNumber)
    // getBlock() doesn't return all the block fields
    // https://github.com/ethers-io/ethers.js/issues/667
    const block = await provider.send('eth_getBlockByNumber', [ethers_1.ethers.utils.hexValue(receipt.blockNumber), true]);
    if (process.env.tempGoerliGethFix === '1') {
        block.miner = '0x0000000000000000000000000000000000000000';
    }
    const tree = await buildTree(provider, block);
    const proof = await extractProof(block, tree, receipt.transactionIndex);
    const filter = contract.filters[eventName]();
    const events = await contract.queryFilter(filter, receipt.blockNumber, receipt.blockNumber);
    const event = events.find(event => event.transactionHash === txHash);
    // `log.logIndex` does not necessarily match the log's order in the array of logs
    const logIndexInArray = receipt.logs.findIndex(l => l.logIndex === event.logIndex);
    const log = receipt.logs[logIndexInArray];
    // @ts-expect-error
    receipt.cumulativeGasUsed = receipt.cumulativeGasUsed.toNumber();
    const formattedProof = new BorshProof({
        log_index: logIndexInArray,
        log_entry_data: Array.from(eth_object_1.Log.fromObject(log).serialize()),
        receipt_index: proof.txIndex,
        receipt_data: Array.from(eth_object_1.Receipt.fromObject(receipt).serialize()),
        header_data: Array.from(proof.header_rlp),
        proof: Array.from(proof.receiptProof).map(ethereumjs_util_1.rlp.encode).map(b => Array.from(b))
    });
    return serialize_1.serialize(proofBorshSchema, formattedProof);
}
exports.findEthProof = findEthProof;
async function buildTree(provider, block) {
    const blockReceipts = await Promise.all(block.transactions.map(async (t) => await provider.getTransactionReceipt(t.hash)));
    /*
    // Keep this here in case we need testing
    const tree = new Tree()
    await Promise.all(
      blockReceipts.map(receipt => {
        const path = rlp.encode(receipt.transactionIndex)
        const serializedReceipt = Receipt.fromWeb3(receipt).serialize()
        return promisfy(tree.put, tree)(path, serializedReceipt)
      })
    )
    console.log(block)
    if (tree.root.toString('hex') !== block.receiptsRoot.slice(2)) {
      throw new Error('Failed to build receipts trie root: tree')
    }
    */
    // Build a Patricia Merkle Trie
    const trie = new lite_merkle_patricia_tree_1.Trie();
    blockReceipts.forEach(receipt => {
        const path = ethereumjs_util_1.rlp.encode(receipt.transactionIndex);
        // @ts-expect-error
        receipt.cumulativeGasUsed = receipt.cumulativeGasUsed.toNumber();
        const serializedReceipt = eth_object_1.Receipt.fromObject(receipt).serialize();
        trie.put(path, serializedReceipt);
    });
    if (trie.root.toString('hex') !== block.receiptsRoot.slice(2)) {
        throw new Error('Failed to build receipts trie root.');
    }
    return trie;
}
async function extractProof(block, tree, transactionIndex) {
    const stack = tree.findPath(ethereumjs_util_1.rlp.encode(transactionIndex)).stack.map(node => { return { raw: node.raw() }; });
    /*
    // Keep this here in case we need testing
    const [, , stack] = await promisfy(
      tree.findPath,
      tree
    )(rlp.encode(transactionIndex))
    */
    // Correctly compose and encode the header.
    const header = eth_object_1.Header.fromRpc(block);
    return {
        header_rlp: header.serialize(),
        receiptProof: eth_object_1.Proof.fromStack(stack),
        txIndex: transactionIndex
    };
}
async function findNearProof(nearReceiptId, nearReceiverId, nearBlockHeight, nearAccount, provider, ethClientAddress, ethClientAbi) {
    const nearOnEthClient = new ethers_1.ethers.Contract(ethClientAddress, ethClientAbi, provider);
    const clientBlockHashB58 = bs58_1.default.encode(ethereumjs_util_1.toBuffer(await nearOnEthClient.blockHashes(nearBlockHeight)));
    const proof = await nearAccount.connection.provider.lightClientProof({
        type: provider_1.IdType.Receipt,
        receipt_id: nearReceiptId,
        receiver_id: nearReceiverId,
        light_client_head: clientBlockHashB58
    });
    return proof;
}
exports.findNearProof = findNearProof;
//# sourceMappingURL=findProof.js.map