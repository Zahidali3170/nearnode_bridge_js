"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.borshifyOutcomeProof = void 0;
const web3_utils_1 = __importDefault(require("web3-utils"));
const bs58_1 = __importDefault(require("bs58"));
// Encode outcome proof according to its borsh schema.
// import { LightClientProof } from 'near-api-js/lib/providers/provider'
// export function borshifyOutcomeProof (proof: LightClientProof): Buffer {
// TODO fix LightClientProof interface
function borshifyOutcomeProof(proof) {
    const statusToBuffer = (status) => {
        if ('SuccessValue' in status) {
            const data = Buffer.from(status.SuccessValue, 'base64');
            return Buffer.concat([
                Buffer.from([2]),
                web3_utils_1.default.toBN(data.length).toBuffer('le', 4),
                data
            ]);
        }
        else if ('SuccessReceiptId' in status) {
            return Buffer.concat([
                Buffer.from([3]),
                bs58_1.default.decode(status.SuccessReceiptId)
            ]);
        }
        else {
            throw new Error('status not supported');
        }
    };
    return Buffer.concat([
        web3_utils_1.default.toBN(proof.outcome_proof.proof.length).toBuffer('le', 4),
        Buffer.concat(proof.outcome_proof.proof.map((p) => Buffer.concat([
            bs58_1.default.decode(p.hash),
            Buffer.from([p.direction === 'Right' ? 1 : 0])
        ]))),
        bs58_1.default.decode(proof.outcome_proof.block_hash),
        bs58_1.default.decode(proof.outcome_proof.id),
        Buffer.concat([
            web3_utils_1.default
                .toBN(proof.outcome_proof.outcome.logs.length)
                .toBuffer('le', 4),
            web3_utils_1.default
                .toBN(proof.outcome_proof.outcome.receipt_ids.length)
                .toBuffer('le', 4),
            Buffer.concat(proof.outcome_proof.outcome.receipt_ids.map((r) => bs58_1.default.decode(r))),
            web3_utils_1.default.toBN(proof.outcome_proof.outcome.gas_burnt).toBuffer('le', 8),
            web3_utils_1.default
                .toBN(proof.outcome_proof.outcome.tokens_burnt)
                .toBuffer('le', 16),
            web3_utils_1.default
                .toBN(proof.outcome_proof.outcome.executor_id.length)
                .toBuffer('le', 4),
            Buffer.from(proof.outcome_proof.outcome.executor_id, 'utf8'),
            statusToBuffer(proof.outcome_proof.outcome.status),
            web3_utils_1.default.toBN(proof.outcome_root_proof.length).toBuffer('le', 4),
            Buffer.concat(proof.outcome_root_proof.map((orp) => Buffer.concat([
                bs58_1.default.decode(orp.hash),
                Buffer.from([orp.direction === 'Right' ? 1 : 0])
            ]))),
            bs58_1.default.decode(proof.block_header_lite.prev_block_hash),
            bs58_1.default.decode(proof.block_header_lite.inner_rest_hash),
            web3_utils_1.default
                .toBN(proof.block_header_lite.inner_lite.height)
                .toBuffer('le', 8),
            bs58_1.default.decode(proof.block_header_lite.inner_lite.epoch_id),
            bs58_1.default.decode(proof.block_header_lite.inner_lite.next_epoch_id),
            bs58_1.default.decode(proof.block_header_lite.inner_lite.prev_state_root),
            bs58_1.default.decode(proof.block_header_lite.inner_lite.outcome_root),
            // for backward compatible in tests with old dumps
            web3_utils_1.default
                .toBN(proof.block_header_lite.inner_lite.timestamp_nanosec ||
                proof.block_header_lite.inner_lite.timestamp)
                .toBuffer('le', 8),
            bs58_1.default.decode(proof.block_header_lite.inner_lite.next_bp_hash),
            bs58_1.default.decode(proof.block_header_lite.inner_lite.block_merkle_root),
            web3_utils_1.default.toBN(proof.block_proof.length).toBuffer('le', 4),
            Buffer.concat(proof.block_proof.map((bp) => Buffer.concat([
                bs58_1.default.decode(bp.hash),
                Buffer.from([bp.direction === 'Right' ? 1 : 0])
            ])))
        ])
    ]);
}
exports.borshifyOutcomeProof = borshifyOutcomeProof;
//# sourceMappingURL=borshify-proof.js.map