import { ethers } from 'ethers';
import { Account } from 'near-api-js';
import { FinalExecutionOutcome } from 'near-api-js/lib/providers';
import { TransferStatus, TransactionInfo } from '@near-eth/client/dist/types';
export declare const SOURCE_NETWORK = "near";
export declare const DESTINATION_NETWORK = "ethereum";
export declare const TRANSFER_TYPE = "@near-eth/near-ether/bridged-ether/sendToEthereum";
export interface TransferDraft extends TransferStatus {
    type: string;
    finalityBlockHeights: number[];
    nearOnEthClientBlockHeight: null | number;
    unlockHashes: string[];
    unlockReceipts: ethers.providers.TransactionReceipt[];
    burnHashes: string[];
    burnReceiptBlockHeights: number[];
    burnReceiptIds: string[];
}
export interface Transfer extends TransferDraft, TransactionInfo {
    id: string;
    startTime: string;
    finishTime?: string;
    decimals: number;
    destinationTokenName: string;
    recipient: string;
    sender: string;
    sourceTokenName: string;
    symbol: string;
    checkSyncInterval?: number;
    nextCheckSyncTimestamp?: Date;
    proof?: Uint8Array;
}
export interface TransferOptions {
    provider?: ethers.providers.Provider;
    etherCustodianAddress?: string;
    etherCustodianAbi?: string;
    sendToEthereumSyncInterval?: number;
    ethChainId?: number;
    nearAccount?: Account;
    ethClientAddress?: string;
    ethClientAbi?: string;
    auroraEvmAccount?: string;
}
export declare const i18n: {
    en_US: {
        steps: (transfer: Transfer) => import("@near-eth/client/dist/types").Step[];
        statusMessage: (transfer: Transfer) => "Failed" | "Ready to transfer from NEAR" | "Ready to deposit in Ethereum" | "Confirming transfer" | "Depositing in Ethereum" | "Transfer complete" | "Transfering from NEAR";
        callToAction: (transfer: Transfer) => "Retry" | "Transfer" | "Deposit" | null;
    };
};
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
export declare function act(transfer: Transfer): Promise<Transfer>;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
export declare function checkStatus(transfer: Transfer): Promise<Transfer>;
/**
 * Find all burn transactions sending nETH back to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options Optional arguments.
 * @param options.auroraEvmAccount nETH bridged ETH account on NEAR (aurora)
 * @returns Array of NEAR transaction hashes.
 */
export declare function findAllTransactions({ fromBlock, toBlock, sender, callIndexer, options }: {
    fromBlock: string;
    toBlock: string;
    sender: string;
    callIndexer: (query: string) => Promise<[{
        originated_from_transaction_hash: string;
        args: {
            method_name: string;
        };
    }]>;
    options?: {
        auroraEvmAccount?: string;
    };
}): Promise<string[]>;
/**
 * Recover all transfers sending nETH back to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
export declare function findAllTransfers({ fromBlock, toBlock, sender, callIndexer, options }: {
    fromBlock: string;
    toBlock: string;
    sender: string;
    callIndexer: (query: string) => Promise<[{
        originated_from_transaction_hash: string;
        args: {
            method_name: string;
        };
    }]>;
    options?: TransferOptions;
}): Promise<Transfer[]>;
/**
 * Recover transfer from a burn tx hash
 * Track a new transfer at the completedStep = BURN so that it can be unlocked
 * @param burnTxHash Near tx hash containing the token withdrawal
 * @param sender Near account sender of burnTxHash
 * @param options TransferOptions optional arguments.
 * @returns The recovered transfer object
 */
export declare function recover(burnTxHash: string, sender?: string, options?: TransferOptions): Promise<Transfer>;
/**
 * Parse the burn receipt id and block height needed to complete
 * the step BURN
 * @param burnTx
 * @param sender
 * @param sourceToken
 * @param nearAccount
 */
export declare function parseWithdrawReceipt(burnTx: FinalExecutionOutcome, sender: string, sourceToken: string, nearAccount: Account): Promise<{
    id: string;
    blockHeight: number;
}>;
/**
 * Initiate a transfer from NEAR to Ethereum by burning nETH tokens.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient Ethereum address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.sender Sender of tokens (defaults to the connected NEAR wallet address).
 * @param options.auroraEvmAccount nETH bridged ETH account on NEAR (aurora)
 * @param params.options.nearAccount Connected NEAR wallet account to use.
 * @returns The created transfer object.
 */
export declare function initiate({ amount, recipient, options }: {
    amount: string | ethers.BigNumber;
    recipient: string;
    options?: {
        sender?: string;
        auroraEvmAccount?: string;
        nearAccount?: Account;
    };
}): Promise<Transfer>;
export declare function burn(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Process a broadcasted burn transaction
 * checkBurn is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkBurn can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
export declare function checkBurn(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Wait for a final block with a strictly greater height than burnTx
 * receipt. This block (or one of its ancestors) should hold the outcome.
 * Although this may not support sharding.
 * TODO: support sharding
 */
export declare function checkFinality(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Wait for the block with the given receipt/transaction in Near2EthClient, and
 * get the outcome proof only use block merkle root that we know is available
 * on the Near2EthClient.
 */
export declare function checkSync(transfer: Transfer | string, options?: TransferOptions): Promise<Transfer>;
/**
 * Check if a NEAR outcome receipt_id has already been used to finalize a transfer to Ethereum.
 */
export declare function proofAlreadyUsed(provider: ethers.providers.Provider, proof: any, etherCustodianAddress: string, etherCustodianAbi: string): Promise<boolean>;
/**
 * Unlock tokens stored in the contract at process.env.ethLockerAddress,
 * passing the proof that the tokens were withdrawn/burned in the corresponding
 * NEAR BridgeToken contract.
 */
export declare function unlock(transfer: Transfer | string, options?: Omit<TransferOptions, 'provider'> & {
    provider?: ethers.providers.JsonRpcProvider;
    signer?: ethers.Signer;
}): Promise<Transfer>;
export declare function checkUnlock(transfer: Transfer, options?: {
    provider?: ethers.providers.Provider;
    ethChainId?: number;
}): Promise<Transfer>;
//# sourceMappingURL=index.d.ts.map