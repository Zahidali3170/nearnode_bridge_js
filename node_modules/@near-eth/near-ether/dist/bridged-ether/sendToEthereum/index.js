"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkUnlock = exports.unlock = exports.proofAlreadyUsed = exports.checkSync = exports.checkFinality = exports.checkBurn = exports.burn = exports.initiate = exports.parseWithdrawReceipt = exports.recover = exports.findAllTransfers = exports.findAllTransactions = exports.checkStatus = exports.act = exports.i18n = exports.TRANSFER_TYPE = exports.DESTINATION_NETWORK = exports.SOURCE_NETWORK = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bs58_1 = __importDefault(require("bs58"));
const ethers_1 = require("ethers");
const near_api_js_1 = require("near-api-js");
const serialize_1 = require("near-api-js/lib/utils/serialize");
const status = __importStar(require("@near-eth/client/dist/statuses"));
const i18nHelpers_1 = require("@near-eth/client/dist/i18nHelpers");
const client_1 = require("@near-eth/client");
const utils_1 = require("@near-eth/utils");
const find_replacement_tx_1 = require("find-replacement-tx");
const utils_2 = require("@near-eth/client/dist/utils");
exports.SOURCE_NETWORK = 'near';
exports.DESTINATION_NETWORK = 'ethereum';
exports.TRANSFER_TYPE = '@near-eth/near-ether/bridged-ether/sendToEthereum';
const BURN = 'burn-bridged-ether-to-natural-ether';
const AWAIT_FINALITY = 'await-finality-bridged-ether-to-natural-ether';
const SYNC = 'sync-bridged-ether-to-natural-ether';
const UNLOCK = 'unlock-bridged-ether-to-natural-ether';
const steps = [
    BURN,
    AWAIT_FINALITY,
    SYNC,
    UNLOCK
];
class TransferError extends Error {
}
const transferDraft = {
    // Attributes common to all transfer types
    // amount,
    completedStep: null,
    // destinationTokenName,
    errors: [],
    // recipient,
    // sender,
    // sourceToken,
    // sourceTokenName,
    // decimals,
    status: status.IN_PROGRESS,
    type: exports.TRANSFER_TYPE,
    // Cache eth tx information used for finding a replaced (speedup/cancel) tx.
    // ethCache: {
    //   from,                     // tx.from of last broadcasted eth tx
    //   to,                       // tx.to of last broadcasted eth tx (can be multisig contract)
    //   safeReorgHeight,          // Lower boundary for replacement tx search
    //   nonce                     // tx.nonce of last broadcasted eth tx
    // }
    // Attributes specific to bridged-nep141-to-erc20 transfers
    finalityBlockHeights: [],
    nearOnEthClientBlockHeight: null,
    unlockHashes: [],
    unlockReceipts: [],
    burnReceiptBlockHeights: [],
    burnReceiptIds: [],
    burnHashes: []
};
/* eslint-disable @typescript-eslint/restrict-template-expressions */
exports.i18n = {
    en_US: {
        steps: (transfer) => i18nHelpers_1.stepsFor(transfer, steps, {
            [BURN]: `Start transfer of ${utils_2.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.sourceTokenName} from NEAR`,
            [AWAIT_FINALITY]: 'Confirm in NEAR',
            [SYNC]: 'Confirm in Ethereum. This can take around 16 hours. Feel free to return to this window later, to complete the final step of the transfer.',
            [UNLOCK]: `Deposit ${utils_2.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.destinationTokenName} in Ethereum`
        }),
        statusMessage: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Failed';
            if (transfer.status === status.ACTION_NEEDED) {
                switch (transfer.completedStep) {
                    case null: return 'Ready to transfer from NEAR';
                    case SYNC: return 'Ready to deposit in Ethereum';
                    default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
                }
            }
            switch (transfer.completedStep) {
                case null: return 'Transfering from NEAR';
                case BURN: return 'Confirming transfer';
                case AWAIT_FINALITY: return 'Confirming transfer';
                case SYNC: return 'Depositing in Ethereum';
                case UNLOCK: return 'Transfer complete';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        },
        callToAction: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Retry';
            if (transfer.status !== status.ACTION_NEEDED)
                return null;
            switch (transfer.completedStep) {
                case null: return 'Transfer';
                case SYNC: return 'Deposit';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        }
    }
};
/* eslint-enable @typescript-eslint/restrict-template-expressions */
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
async function act(transfer) {
    switch (transfer.completedStep) {
        case null:
            try {
                return await burn(transfer);
            }
            catch (error) {
                console.error(error);
                if (error.message.includes('Failed to redirect to sign transaction')) {
                    // Increase time to redirect to wallet before recording an error
                    await new Promise(resolve => setTimeout(resolve, 10000));
                }
                if (typeof window !== 'undefined')
                    utils_1.urlParams.clear('withdrawing');
                throw error;
            }
        case AWAIT_FINALITY: return await checkSync(transfer);
        case SYNC: return await unlock(transfer);
        default: throw new Error(`Don't know how to act on transfer: ${JSON.stringify(transfer)}`);
    }
}
exports.act = act;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
async function checkStatus(transfer) {
    switch (transfer.completedStep) {
        case null: return await checkBurn(transfer);
        case BURN: return await checkFinality(transfer);
        case AWAIT_FINALITY: return await checkSync(transfer);
        case SYNC: return await checkUnlock(transfer);
        default: throw new Error(`Don't know how to checkStatus for transfer ${transfer.id}`);
    }
}
exports.checkStatus = checkStatus;
/**
 * Find all burn transactions sending nETH back to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options Optional arguments.
 * @param options.auroraEvmAccount nETH bridged ETH account on NEAR (aurora)
 * @returns Array of NEAR transaction hashes.
 */
async function findAllTransactions({ fromBlock, toBlock, sender, callIndexer, options }) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const auroraEvmAccount = (_a = options.auroraEvmAccount) !== null && _a !== void 0 ? _a : bridgeParams.auroraEvmAccount;
    const transactions = await callIndexer(utils_1.buildIndexerTxQuery({ fromBlock, toBlock, predecessorAccountId: sender, receiverAccountId: auroraEvmAccount }));
    return transactions.filter(tx => tx.args.method_name === 'withdraw').map(tx => tx.originated_from_transaction_hash);
}
exports.findAllTransactions = findAllTransactions;
/**
 * Recover all transfers sending nETH back to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
async function findAllTransfers({ fromBlock, toBlock, sender, callIndexer, options }) {
    const burnTransactions = await findAllTransactions({ fromBlock, toBlock, sender, callIndexer, options });
    const transfers = await Promise.all(burnTransactions.map(async (tx) => {
        try {
            return await recover(tx, sender, options);
        }
        catch (error) {
            // Unlike with Ethereum events, the transaction exists even if it failed.
            // So ignore the transfer if it cannot be recovered
            console.log('Failed to recover transfer (transaction failed ?): ', tx, error);
            return null;
        }
    }));
    return transfers.filter((transfer) => transfer !== null);
}
exports.findAllTransfers = findAllTransfers;
/**
 * Recover transfer from a burn tx hash
 * Track a new transfer at the completedStep = BURN so that it can be unlocked
 * @param burnTxHash Near tx hash containing the token withdrawal
 * @param sender Near account sender of burnTxHash
 * @param options TransferOptions optional arguments.
 * @returns The recovered transfer object
 */
async function recover(burnTxHash, sender = 'todo', options) {
    var _a, _b, _c, _d;
    options = options !== null && options !== void 0 ? options : {};
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    const bridgeParams = utils_2.getBridgeParams();
    const decodedTxHash = near_api_js_1.utils.serialize.base_decode(burnTxHash);
    const burnTx = await nearAccount.connection.provider.txStatus(
    // TODO: when multiple shards, the sender should be known in order to query txStatus
    decodedTxHash, sender);
    sender = burnTx.transaction.signer_id;
    // @ts-expect-error TODO
    if (burnTx.status.Unknown) {
        // Transaction or receipt not processed yet
        throw new Error(`Burn transaction pending: ${burnTxHash}`);
    }
    // @ts-expect-error TODO
    if (burnTx.status.Failure) {
        throw new Error(`Burn transaction failed: ${burnTxHash}`);
    }
    // Get burn event information from successValue
    // @ts-expect-error TODO
    const successValue = burnTx.status.SuccessValue;
    if (!successValue) {
        throw new Error(`Invalid burnTx successValue: '${successValue}'
      Full withdrawal transaction: ${JSON.stringify(burnTx)}`);
    }
    // eslint-disable-next-line @typescript-eslint/no-extraneous-class
    class WithdrawEvent {
        constructor(args) {
            Object.assign(this, args);
        }
    }
    const SCHEMA = new Map([
        [WithdrawEvent, {
                kind: 'struct',
                fields: [
                    ['amount', 'u128'],
                    ['recipient_id', [20]],
                    ['eth_custodian_address', [20]]
                ]
            }]
    ]);
    const withdrawEvent = serialize_1.deserialize(SCHEMA, WithdrawEvent, Buffer.from(successValue, 'base64'));
    const amount = withdrawEvent.amount.toString();
    const recipient = '0x' + Buffer.from(withdrawEvent.recipient_id).toString('hex');
    const etherCustodian = '0x' + Buffer.from(withdrawEvent.eth_custodian_address).toString('hex');
    const etherCustodianAddress = (_b = options.etherCustodianAddress) !== null && _b !== void 0 ? _b : bridgeParams.etherCustodianAddress;
    if (etherCustodian !== etherCustodianAddress.toLowerCase()) {
        throw new Error('Failed to verify ETH custodian address.');
    }
    const symbol = 'ETH';
    const destinationTokenName = symbol;
    const sourceTokenName = 'n' + symbol;
    const sourceToken = (_c = options.auroraEvmAccount) !== null && _c !== void 0 ? _c : bridgeParams.auroraEvmAccount;
    const decimals = 18;
    const withdrawReceipt = await parseWithdrawReceipt(burnTx, sender, (_d = options.auroraEvmAccount) !== null && _d !== void 0 ? _d : bridgeParams.auroraEvmAccount, nearAccount);
    // @ts-expect-error TODO
    const txBlock = await nearAccount.connection.provider.block({ blockId: burnTx.transaction_outcome.block_hash });
    // various attributes stored as arrays, to keep history of retries
    const transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date(txBlock.header.timestamp / 10 ** 6).toISOString(),
        amount: amount.toString(),
        completedStep: BURN,
        destinationTokenName,
        recipient,
        sender,
        symbol,
        sourceTokenName,
        sourceToken,
        decimals,
        burnHashes: [burnTxHash],
        burnReceiptBlockHeights: [withdrawReceipt.blockHeight],
        burnReceiptIds: [withdrawReceipt.id]
    };
    // Check transfer status
    return await checkSync(transfer, options);
}
exports.recover = recover;
/**
 * Parse the burn receipt id and block height needed to complete
 * the step BURN
 * @param burnTx
 * @param sender
 * @param sourceToken
 * @param nearAccount
 */
async function parseWithdrawReceipt(burnTx, sender, sourceToken, nearAccount) {
    const receiptIds = burnTx.transaction_outcome.outcome.receipt_ids;
    if (receiptIds.length !== 1) {
        throw new TransferError(`Withdrawal expects only one receipt, got ${receiptIds.length}.
      Full withdrawal transaction: ${JSON.stringify(burnTx)}`);
    }
    // Get receipt information for recording and building burn proof
    const successReceiptId = receiptIds[0];
    const successReceiptOutcome = burnTx.receipts_outcome
        .find(r => r.id === successReceiptId)
        .outcome;
    // @ts-expect-error TODO
    const successReceiptExecutorId = successReceiptOutcome.executor_id;
    let withdrawReceiptId;
    // Check if this tx was made from a 2fa
    switch (successReceiptExecutorId) {
        case sender: {
            // `confirm` transaction executed on 2fa account
            // @ts-expect-error TODO
            withdrawReceiptId = successReceiptOutcome.status.SuccessReceiptId;
            const withdrawReceiptOutcome = burnTx.receipts_outcome
                .find(r => r.id === withdrawReceiptId)
                .outcome;
            // @ts-expect-error TODO
            const withdrawReceiptExecutorId = withdrawReceiptOutcome.executor_id;
            // Expect this receipt to be the 2fa FunctionCall
            if (withdrawReceiptExecutorId !== sourceToken) {
                throw new TransferError(`Unexpected receipt outcome format in 2fa transaction.
          Expected sourceToken '${sourceToken}', got '${withdrawReceiptExecutorId}'
          Full withdrawal transaction: ${JSON.stringify(burnTx)}`);
            }
            break;
        }
        case sourceToken:
            // `burn` called directly, successReceiptId is already correct, nothing to do
            withdrawReceiptId = successReceiptId;
            break;
        default:
            throw new TransferError(`Unexpected receipt outcome format.
        Full withdrawal transaction: ${JSON.stringify(burnTx)}`);
    }
    const txReceiptBlockHash = burnTx.receipts_outcome
        .find(r => r.id === withdrawReceiptId)
        // @ts-expect-error TODO
        .block_hash;
    const receiptBlock = await nearAccount.connection.provider.block({
        blockId: txReceiptBlockHash
    });
    const receiptBlockHeight = Number(receiptBlock.header.height);
    return { id: withdrawReceiptId, blockHeight: receiptBlockHeight };
}
exports.parseWithdrawReceipt = parseWithdrawReceipt;
/**
 * Initiate a transfer from NEAR to Ethereum by burning nETH tokens.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient Ethereum address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.sender Sender of tokens (defaults to the connected NEAR wallet address).
 * @param options.auroraEvmAccount nETH bridged ETH account on NEAR (aurora)
 * @param params.options.nearAccount Connected NEAR wallet account to use.
 * @returns The created transfer object.
 */
async function initiate({ amount, recipient, options }) {
    var _a, _b, _c;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const decimals = 18;
    const symbol = 'ETH';
    const destinationTokenName = symbol;
    const sourceTokenName = 'n' + symbol;
    const sourceToken = (_a = options.auroraEvmAccount) !== null && _a !== void 0 ? _a : bridgeParams.auroraEvmAccount;
    const nearAccount = (_b = options.nearAccount) !== null && _b !== void 0 ? _b : await utils_2.getNearAccount();
    const sender = (_c = options.sender) !== null && _c !== void 0 ? _c : nearAccount.accountId;
    // various attributes stored as arrays, to keep history of retries
    let transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date().toISOString(),
        amount: amount.toString(),
        destinationTokenName,
        recipient,
        sender,
        sourceToken,
        sourceTokenName,
        symbol,
        decimals
    };
    try {
        transfer = await burn(transfer, options);
    }
    catch (error) {
        if (error.message.includes('Failed to redirect to sign transaction')) {
            // Increase time to redirect to wallet before alerting an error
            await new Promise(resolve => setTimeout(resolve, 10000));
        }
        if (typeof window !== 'undefined' && utils_1.urlParams.get('withdrawing')) {
            // If the urlParam is set then the transfer was tracked so delete it.
            await client_1.untrack(utils_1.urlParams.get('withdrawing'));
            utils_1.urlParams.clear('withdrawing');
        }
        // Throw the error to be handled by frontend
        throw error;
    }
    return transfer;
}
exports.initiate = initiate;
async function burn(transfer, options) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    // eslint-disable-next-line @typescript-eslint/no-extraneous-class
    class BorshWithdrawArgs {
        constructor(args) {
            Object.assign(this, args);
        }
    }
    ;
    const withdrawCallArgsSchema = new Map([
        [BorshWithdrawArgs, {
                kind: 'struct',
                fields: [
                    ['recipient_id', [20]],
                    ['amount', 'u128']
                    // TODO
                    // ['fee', 'u128']
                ]
            }]
    ]);
    const args = new BorshWithdrawArgs({
        recipient_id: ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.getAddress(transfer.recipient)),
        amount: transfer.amount.toString()
        // fee: fee.toString(),
    });
    const serializedArgs = serialize_1.serialize(withdrawCallArgsSchema, args);
    // NOTE:
    // checkStatus should wait for NEAR wallet redirect if it didn't happen yet.
    // On page load the dapp should clear urlParams if transactionHashes or errorCode are not present:
    // this will allow checkStatus to handle the transfer as failed because the NEAR transaction could not be processed.
    if (typeof window !== 'undefined')
        utils_1.urlParams.set({ withdrawing: transfer.id });
    if (typeof window !== 'undefined')
        transfer = await client_1.track({ ...transfer, status: status.IN_PROGRESS });
    const tx = await nearAccount.functionCall({
        contractId: transfer.sourceToken,
        methodName: 'withdraw',
        args: serializedArgs,
        // 100Tgas: enough for execution, not too much so that a 2fa tx is within 300Tgas
        gas: new bn_js_1.default('100' + '0'.repeat(12)),
        attachedDeposit: new bn_js_1.default('1')
    });
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        burnHashes: [...transfer.burnHashes, tx.transaction.hash]
    };
}
exports.burn = burn;
/**
 * Process a broadcasted burn transaction
 * checkBurn is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkBurn can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
async function checkBurn(transfer, options) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const id = utils_1.urlParams.get('withdrawing');
    // NOTE: when a single tx is executed, transactionHashes is equal to that hash
    const txHash = utils_1.urlParams.get('transactionHashes');
    const errorCode = utils_1.urlParams.get('errorCode');
    const clearParams = ['withdrawing', 'transactionHashes', 'errorCode', 'errorMessage'];
    if (!id) {
        // The user closed the tab and never rejected or approved the tx from Near wallet.
        // This doesn't protect agains the user broadcasting a tx and closing the tab before
        // redirect. So the dapp has no way of knowing the status of that transaction.
        // Set status to FAILED so that it can be retried
        const newError = `A transaction was initiated but could not be verified.
      Click 'Rescan the blockchain' to check if a transfer was created.`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (id !== transfer.id) {
        // Another burn transaction cannot be in progress, ie if checkBurn is called on
        // an in process burn then the transfer ids must be equal or the url callback is invalid.
        const newError = `Couldn't determine transaction outcome.
      Got transfer id '${id} in URL, expected '${transfer.id}`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (errorCode) {
        // If errorCode, then the redirect succeded but the tx was rejected/failed
        // so clear url params
        utils_1.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: ' + errorCode;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (!txHash) {
        // If checkBurn is called before burn sig wallet redirect
        // log the error but don't mark as FAILED and don't clear url params
        // as the wallet redirect has not happened yet
        const newError = 'Burn tx hash not received: pending redirect or wallet error';
        console.log(newError);
        return transfer;
    }
    if (txHash.includes(',')) {
        utils_1.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: expected single txHash, got: ' + txHash;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    const decodedTxHash = near_api_js_1.utils.serialize.base_decode(txHash);
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    const burnTx = await nearAccount.connection.provider.txStatus(
    // use transfer.sender instead of nearAccount.accountId so that a burn
    // tx hash can be recovered even if it is not made by the logged in account
    decodedTxHash, transfer.sender);
    // @ts-expect-error : wallet returns errorCode
    if (burnTx.status.Unknown) {
        // Transaction or receipt not processed yet
        return transfer;
    }
    // Check status of tx broadcasted by wallet
    // @ts-expect-error : wallet returns errorCode
    if (burnTx.status.Failure) {
        utils_1.urlParams.clear(...clearParams);
        const error = `NEAR transaction failed: ${txHash}`;
        console.error(error);
        return {
            ...transfer,
            errors: [...transfer.errors, error],
            status: status.FAILED,
            burnHashes: [...transfer.burnHashes, txHash]
        };
    }
    let withdrawReceipt;
    try {
        withdrawReceipt = await parseWithdrawReceipt(burnTx, transfer.sender, transfer.sourceToken, nearAccount);
    }
    catch (e) {
        if (e instanceof TransferError) {
            utils_1.urlParams.clear(...clearParams);
            return {
                ...transfer,
                errors: [...transfer.errors, e.message],
                status: status.FAILED,
                burnHashes: [...transfer.burnHashes, txHash]
            };
        }
        // Any other error like provider connection error should throw
        // so that the transfer stays in progress and checkBurn will be called again.
        throw e;
    }
    // @ts-expect-error TODO
    const txBlock = await nearAccount.connection.provider.block({ blockId: burnTx.transaction_outcome.block_hash });
    const startTime = new Date(txBlock.header.timestamp / 10 ** 6).toISOString();
    // Clear urlParams at the end so that if the provider connection throws,
    // checkStatus will be able to process it again in the next loop.
    utils_1.urlParams.clear(...clearParams);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        completedStep: BURN,
        startTime,
        burnReceiptIds: [...transfer.burnReceiptIds, withdrawReceipt.id],
        burnReceiptBlockHeights: [...transfer.burnReceiptBlockHeights, withdrawReceipt.blockHeight],
        burnHashes: [...transfer.burnHashes, txHash]
    };
}
exports.checkBurn = checkBurn;
/**
 * Wait for a final block with a strictly greater height than burnTx
 * receipt. This block (or one of its ancestors) should hold the outcome.
 * Although this may not support sharding.
 * TODO: support sharding
 */
async function checkFinality(transfer, options) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    const withdrawReceiptBlockHeight = last(transfer.burnReceiptBlockHeights);
    const latestFinalizedBlock = Number((await nearAccount.connection.provider.block({ finality: 'final' })).header.height);
    if (latestFinalizedBlock <= withdrawReceiptBlockHeight) {
        return transfer;
    }
    return {
        ...transfer,
        completedStep: AWAIT_FINALITY,
        status: status.IN_PROGRESS,
        finalityBlockHeights: [...transfer.finalityBlockHeights, latestFinalizedBlock]
    };
}
exports.checkFinality = checkFinality;
/**
 * Wait for the block with the given receipt/transaction in Near2EthClient, and
 * get the outcome proof only use block merkle root that we know is available
 * on the Near2EthClient.
 */
async function checkSync(transfer, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    if (typeof transfer === 'string') {
        return await recover(transfer, 'todo', options);
    }
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_2.getEthProvider();
    if (!transfer.checkSyncInterval) {
        // checkSync every 60s: reasonable value to detect transfer is ready to be finalized
        transfer = {
            ...transfer,
            checkSyncInterval: (_b = options.sendToEthereumSyncInterval) !== null && _b !== void 0 ? _b : bridgeParams.sendToEthereumSyncInterval
        };
    }
    if (transfer.nextCheckSyncTimestamp && new Date() < new Date(transfer.nextCheckSyncTimestamp)) {
        return transfer;
    }
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_c = options.ethChainId) !== null && _c !== void 0 ? _c : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        throw new Error(`Wrong eth network for checkSync, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const withdrawBlockHeight = last(transfer.burnReceiptBlockHeights);
    const nearOnEthClientBlockHeight = await utils_1.nearOnEthSyncHeight(provider, (_d = options.ethClientAddress) !== null && _d !== void 0 ? _d : bridgeParams.ethClientAddress, (_e = options.ethClientAbi) !== null && _e !== void 0 ? _e : bridgeParams.ethClientAbi);
    let proof;
    const nearAccount = (_f = options.nearAccount) !== null && _f !== void 0 ? _f : await utils_2.getNearAccount();
    if (nearOnEthClientBlockHeight > withdrawBlockHeight) {
        proof = await utils_1.findNearProof(last(transfer.burnReceiptIds), (_g = options.auroraEvmAccount) !== null && _g !== void 0 ? _g : bridgeParams.auroraEvmAccount, nearOnEthClientBlockHeight, nearAccount, provider, (_h = options.ethClientAddress) !== null && _h !== void 0 ? _h : bridgeParams.ethClientAddress, (_j = options.ethClientAbi) !== null && _j !== void 0 ? _j : bridgeParams.ethClientAbi);
        if (await proofAlreadyUsed(provider, proof, (_k = options.etherCustodianAddress) !== null && _k !== void 0 ? _k : bridgeParams.etherCustodianAddress, (_l = options.etherCustodianAbi) !== null && _l !== void 0 ? _l : bridgeParams.etherCustodianAbi)) {
            try {
                const { transactions, block } = await utils_1.findFinalizationTxOnEthereum({
                    usedProofPosition: '3',
                    proof,
                    connectorAddress: (_m = options.etherCustodianAddress) !== null && _m !== void 0 ? _m : bridgeParams.etherCustodianAddress,
                    connectorAbi: (_o = options.etherCustodianAbi) !== null && _o !== void 0 ? _o : bridgeParams.etherCustodianAbi,
                    finalizationEvent: 'Withdrawn',
                    recipient: transfer.recipient,
                    amount: transfer.amount,
                    provider
                });
                transfer = {
                    ...transfer,
                    finishTime: new Date(block.timestamp * 1000).toISOString(),
                    unlockHashes: [...transfer.unlockHashes, ...transactions]
                };
            }
            catch (error) {
                // Not finding the finalization tx should not prevent processing/recovering the transfer.
                console.error(error);
            }
            return {
                ...transfer,
                completedStep: UNLOCK,
                nearOnEthClientBlockHeight,
                status: status.COMPLETE,
                errors: [...transfer.errors, 'Unlock proof already used.']
            };
        }
    }
    else {
        return {
            ...transfer,
            nextCheckSyncTimestamp: new Date(Date.now() + transfer.checkSyncInterval),
            nearOnEthClientBlockHeight,
            status: status.IN_PROGRESS
        };
    }
    return {
        ...transfer,
        completedStep: SYNC,
        nearOnEthClientBlockHeight,
        status: status.ACTION_NEEDED,
        proof // used when checkSync() is called by unlock()
    };
}
exports.checkSync = checkSync;
/**
 * Check if a NEAR outcome receipt_id has already been used to finalize a transfer to Ethereum.
 */
async function proofAlreadyUsed(provider, proof, etherCustodianAddress, etherCustodianAbi) {
    const ethTokenLocker = new ethers_1.ethers.Contract(etherCustodianAddress, etherCustodianAbi, provider);
    const proofIsUsed = await ethTokenLocker.usedEvents_('0x' + bs58_1.default.decode(proof.outcome_proof.outcome.receipt_ids[0]).toString('hex'));
    return proofIsUsed;
}
exports.proofAlreadyUsed = proofAlreadyUsed;
/**
 * Unlock tokens stored in the contract at process.env.ethLockerAddress,
 * passing the proof that the tokens were withdrawn/burned in the corresponding
 * NEAR BridgeToken contract.
 */
async function unlock(transfer, options) {
    var _a, _b, _c, _d;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_2.getSignerProvider();
    // Build burn proof
    transfer = await checkSync(transfer, { ...options, provider });
    if (transfer.status !== status.ACTION_NEEDED)
        return transfer;
    const proof = transfer.proof;
    const borshProof = utils_1.borshifyOutcomeProof(proof);
    const ethTokenLocker = new ethers_1.ethers.Contract((_b = options.etherCustodianAddress) !== null && _b !== void 0 ? _b : bridgeParams.etherCustodianAddress, (_c = options.etherCustodianAbi) !== null && _c !== void 0 ? _c : bridgeParams.etherCustodianAbi, (_d = options.signer) !== null && _d !== void 0 ? _d : provider.getSigner());
    // If this tx is dropped and replaced, lower the search boundary
    // in case there was a reorg.
    const safeReorgHeight = await provider.getBlockNumber() - 20;
    const pendingUnlockTx = await ethTokenLocker.withdraw(borshProof, transfer.nearOnEthClientBlockHeight);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        ethCache: {
            from: pendingUnlockTx.from,
            to: pendingUnlockTx.to,
            nonce: pendingUnlockTx.nonce,
            data: pendingUnlockTx.data,
            safeReorgHeight
        },
        unlockHashes: [...transfer.unlockHashes, pendingUnlockTx.hash]
    };
}
exports.unlock = unlock;
async function checkUnlock(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_2.getEthProvider();
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        throw new Error(`Wrong eth network for checkUnlock, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const unlockHash = last(transfer.unlockHashes);
    let unlockReceipt = await provider.getTransactionReceipt(unlockHash);
    // If no receipt, check that the transaction hasn't been replaced (speedup or canceled)
    if (!unlockReceipt) {
        // don't break old transfers in case they were made before this functionality is released
        if (!transfer.ethCache)
            return transfer;
        try {
            const tx = {
                nonce: transfer.ethCache.nonce,
                from: transfer.ethCache.from,
                to: transfer.ethCache.to,
                data: transfer.ethCache.data
            };
            const foundTx = await find_replacement_tx_1.findReplacementTx(provider, transfer.ethCache.safeReorgHeight, tx);
            if (!foundTx)
                return transfer;
            unlockReceipt = await provider.getTransactionReceipt(foundTx.hash);
        }
        catch (error) {
            console.error(error);
            if (error instanceof find_replacement_tx_1.TxValidationError) {
                return {
                    ...transfer,
                    errors: [...transfer.errors, error.message],
                    status: status.FAILED
                };
            }
            throw error;
        }
    }
    if (!unlockReceipt)
        return transfer;
    if (!unlockReceipt.status) {
        const error = `Transaction failed: ${unlockReceipt.transactionHash}`;
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, error],
            unlockReceipts: [...transfer.unlockReceipts, unlockReceipt]
        };
    }
    if (unlockReceipt.transactionHash !== unlockHash) {
        // Record the replacement tx unlockHash
        transfer = {
            ...transfer,
            unlockHashes: [...transfer.unlockHashes, unlockReceipt.transactionHash]
        };
    }
    const block = await provider.getBlock(unlockReceipt.blockNumber);
    return {
        ...transfer,
        status: status.COMPLETE,
        completedStep: UNLOCK,
        finishTime: new Date(block.timestamp * 1000).toISOString(),
        unlockReceipts: [...transfer.unlockReceipts, unlockReceipt]
    };
}
exports.checkUnlock = checkUnlock;
const last = (arr) => arr[arr.length - 1];
//# sourceMappingURL=index.js.map