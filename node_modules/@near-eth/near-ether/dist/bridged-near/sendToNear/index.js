"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkUnlock = exports.unlock = exports.checkSync = exports.checkBurn = exports.burn = exports.initiate = exports.recover = exports.findAllTransfers = exports.findAllTransactions = exports.checkStatus = exports.act = exports.i18n = exports.TRANSFER_TYPE = exports.DESTINATION_NETWORK = exports.SOURCE_NETWORK = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const ethers_1 = require("ethers");
const client_1 = require("@near-eth/client");
const near_api_js_1 = require("near-api-js");
const i18nHelpers_1 = require("@near-eth/client/dist/i18nHelpers");
const status = __importStar(require("@near-eth/client/dist/statuses"));
const utils_1 = require("@near-eth/client/dist/utils");
const utils_2 = require("@near-eth/utils");
const find_replacement_tx_1 = require("find-replacement-tx");
exports.SOURCE_NETWORK = 'ethereum';
exports.DESTINATION_NETWORK = 'near';
exports.TRANSFER_TYPE = '@near-eth/near-ether/bridged-near/sendToNear';
const BURN = 'burn-e-near-to-natural-near';
const SYNC = 'sync-e-near-to-natural-near';
const UNLOCK = 'unlock-e-near-to-natural-near';
const steps = [
    BURN,
    SYNC,
    UNLOCK
];
const transferDraft = {
    // Attributes common to all transfer types
    // amount,
    completedStep: null,
    // destinationTokenName,
    errors: [],
    // recipient,
    // sender,
    // sourceToken: erc20Address,
    // sourceTokenName,
    // decimals,
    status: status.ACTION_NEEDED,
    type: exports.TRANSFER_TYPE,
    // Cache eth tx information used for finding a replaced (speedup/cancel) tx.
    // ethCache: {
    //   from,                     // tx.from of last broadcasted eth tx
    //   to,                       // tx.to of last broadcasted eth tx (can be multisig contract)
    //   safeReorgHeight,          // Lower boundary for replacement tx search
    //   nonce                     // tx.nonce of last broadcasted eth tx
    // }
    // Attributes specific to natural-erc20-to-nep141 transfers
    completedConfirmations: 0,
    burnHashes: [],
    burnReceipts: [],
    neededConfirmations: 20,
    unlockHashes: []
};
/* eslint-disable @typescript-eslint/restrict-template-expressions */
exports.i18n = {
    en_US: {
        steps: (transfer) => i18nHelpers_1.stepsFor(transfer, steps, {
            [BURN]: `Start transfer of ${utils_1.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.sourceTokenName} from Ethereum`,
            [SYNC]: `Wait for ${transfer.neededConfirmations + Number(utils_1.getBridgeParams().nearEventRelayerMargin)} transfer confirmations for security`,
            [UNLOCK]: `Deposit ${utils_1.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.destinationTokenName} in NEAR`
        }),
        statusMessage: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Failed';
            if (transfer.status === status.ACTION_NEEDED) {
                switch (transfer.completedStep) {
                    case null: return 'Ready to transfer from Ethereum';
                    case SYNC: return 'Ready to deposit in NEAR';
                    default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
                }
            }
            switch (transfer.completedStep) {
                case null: return 'Transfering to NEAR';
                case BURN: return `Confirming transfer ${transfer.completedConfirmations + 1} of ${transfer.neededConfirmations + Number(utils_1.getBridgeParams().nearEventRelayerMargin)}`;
                case SYNC: return 'Depositing in NEAR';
                case UNLOCK: return 'Transfer complete';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        },
        callToAction: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Retry';
            if (transfer.status !== status.ACTION_NEEDED)
                return null;
            switch (transfer.completedStep) {
                case null: return 'Transfer';
                case SYNC: return 'Deposit';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        }
    }
};
/* eslint-enable @typescript-eslint/restrict-template-expressions */
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
async function act(transfer) {
    switch (transfer.completedStep) {
        case null: return await burn(transfer);
        case BURN: return await checkSync(transfer);
        case SYNC:
            try {
                return await unlock(transfer);
            }
            catch (error) {
                console.error(error);
                if (error.message.includes('Failed to redirect to sign transaction')) {
                    // Increase time to redirect to wallet before recording an error
                    await new Promise(resolve => setTimeout(resolve, 10000));
                }
                if (typeof window !== 'undefined')
                    utils_2.urlParams.clear('unlocking');
                throw error;
            }
        default: throw new Error(`Don't know how to act on transfer: ${transfer.id}`);
    }
}
exports.act = act;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
async function checkStatus(transfer) {
    switch (transfer.completedStep) {
        case null: return await checkBurn(transfer);
        case BURN: return await checkSync(transfer);
        case SYNC: return await checkUnlock(transfer);
        default: throw new Error(`Don't know how to checkStatus for transfer ${transfer.id}`);
    }
}
exports.checkStatus = checkStatus;
/**
 * Find all burn transactions sending wNEAR back to NEAR.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.options Optional arguments.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.eNEARAddress ERC-20 NEAR on Ethereum address.
 * @param params.options.eNEARAbi ERC-20 NEAR on Ethereum abi.
 * @returns Array of Ethereum transaction hashes.
 */
async function findAllTransactions({ fromBlock, toBlock, sender, options }) {
    var _a, _b, _c;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const ethTokenLocker = new ethers_1.ethers.Contract((_b = options.eNEARAddress) !== null && _b !== void 0 ? _b : bridgeParams.eNEARAddress, (_c = options.eNEARAbi) !== null && _c !== void 0 ? _c : bridgeParams.eNEARAbi, provider);
    const filter = ethTokenLocker.filters.TransferToNearInitiated(sender);
    const events = await ethTokenLocker.queryFilter(filter, fromBlock, toBlock);
    return events.filter(event => !event.args.accountId.startsWith('aurora:')).map(event => event.transactionHash);
}
exports.findAllTransactions = findAllTransactions;
/**
 * Recover all transfers sending wNEAR back to Near.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
async function findAllTransfers({ fromBlock, toBlock, sender, options }) {
    const lockTransactions = await findAllTransactions({ fromBlock, toBlock, sender, options });
    const transfers = await Promise.all(lockTransactions.map(async (tx) => await recover(tx, options)));
    return transfers;
}
exports.findAllTransfers = findAllTransfers;
/**
 * Recover transfer from a burn tx hash
 * Track a new transfer at the completedStep = BURN so that it can be unlocked
 * @param burnTxHash Ethereum transaction hash which initiated the transfer.
 * @param options TransferOptions optional arguments.
 * @returns The recovered transfer object
 */
async function recover(burnTxHash, options) {
    var _a, _b, _c, _d;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const receipt = await provider.getTransactionReceipt(burnTxHash);
    const eNEAR = new ethers_1.ethers.Contract((_b = options.eNEARAddress) !== null && _b !== void 0 ? _b : bridgeParams.eNEARAddress, (_c = options.eNEARAbi) !== null && _c !== void 0 ? _c : bridgeParams.eNEARAbi, provider);
    const filter = eNEAR.filters.TransferToNearInitiated();
    const events = await eNEAR.queryFilter(filter, receipt.blockNumber, receipt.blockNumber);
    const burnEvent = events.find(event => event.transactionHash === burnTxHash);
    if (!burnEvent) {
        throw new Error('Unable to process burn transaction event.');
    }
    // TODO recover and check eNEAR address. (checking receipt.to doesn't work with multisigs)
    // const erc20Address = burnEvent.args!.token
    const erc20Address = (_d = options.eNEARAddress) !== null && _d !== void 0 ? _d : bridgeParams.eNEARAddress;
    const amount = burnEvent.args.amount.toString();
    const recipient = burnEvent.args.accountId;
    const sender = burnEvent.args.sender;
    const symbol = 'NEAR';
    const sourceTokenName = symbol;
    const decimals = 24;
    const destinationTokenName = symbol;
    const txBlock = await burnEvent.getBlock();
    const transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date(txBlock.timestamp * 1000).toISOString(),
        amount: amount.toString(),
        completedStep: BURN,
        destinationTokenName,
        recipient,
        sender,
        sourceToken: erc20Address,
        sourceTokenName,
        symbol,
        decimals,
        status: status.IN_PROGRESS,
        burnHashes: [burnTxHash],
        burnReceipts: [receipt]
    };
    // Check transfer status
    return await checkSync(transfer, options);
}
exports.recover = recover;
/**
 * Initiate a transfer from Ethereum to NEAR by burning bridged eNEAR tokens.
 * Broadcasts the burn transaction and creates a transfer object.
 * The receipt will be fetched by checkStatus.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient NEAR address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.sender Sender of tokens (defaults to the connected wallet address).
 * @param params.options.ethChainId Ethereum chain id of the bridge.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.eNEARAddress ERC-20 NEAR on Ethereum address.
 * @param params.options.eNEARAbi ERC-20 NEAR on Ethereum abi.
 * @param params.options.signer Ethers signer to use.
 * @returns The created transfer object.
 */
async function initiate({ amount, recipient, options }) {
    var _a, _b, _c, _d;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getSignerProvider();
    const symbol = 'NEAR';
    const sourceTokenName = symbol;
    const destinationTokenName = symbol;
    const decimals = 24;
    const signer = (_b = options.signer) !== null && _b !== void 0 ? _b : provider.getSigner();
    const sender = (_c = options.sender) !== null && _c !== void 0 ? _c : (await signer.getAddress()).toLowerCase();
    // various attributes stored as arrays, to keep history of retries
    let transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date().toISOString(),
        amount: amount.toString(),
        destinationTokenName,
        recipient,
        sender,
        sourceToken: (_d = options.eNEARAddress) !== null && _d !== void 0 ? _d : bridgeParams.eNEARAddress,
        symbol,
        sourceTokenName,
        decimals
    };
    transfer = await burn(transfer, options);
    if (typeof window !== 'undefined')
        transfer = await client_1.track(transfer);
    return transfer;
}
exports.initiate = initiate;
/**
 * Initiate "burn" transaction.
 * Only wait for transaction to have dependable transactionHash created. Avoid
 * blocking to wait for transaction to be mined. Status of transactionHash
 * being mined is then checked in checkStatus.
 */
async function burn(transfer, options) {
    var _a, _b, _c, _d, _e;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getSignerProvider();
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        // Webapp should prevent the user from confirming if the wrong network is selected
        throw new Error(`Wrong eth network for burn, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const ethTokenLocker = new ethers_1.ethers.Contract((_c = options.eNEARAddress) !== null && _c !== void 0 ? _c : bridgeParams.eNEARAddress, (_d = options.eNEARAbi) !== null && _d !== void 0 ? _d : bridgeParams.eNEARAbi, (_e = options.signer) !== null && _e !== void 0 ? _e : provider.getSigner());
    // If this tx is dropped and replaced, lower the search boundary
    // in case there was a reorg.
    const safeReorgHeight = await provider.getBlockNumber() - 20;
    const pendingBurnTx = await ethTokenLocker.transferToNear(transfer.amount, transfer.recipient);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        ethCache: {
            from: pendingBurnTx.from,
            to: pendingBurnTx.to,
            safeReorgHeight,
            data: pendingBurnTx.data,
            nonce: pendingBurnTx.nonce
        },
        burnHashes: [...transfer.burnHashes, pendingBurnTx.hash]
    };
}
exports.burn = burn;
async function checkBurn(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const burnHash = last(transfer.burnHashes);
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        throw new Error(`Wrong eth network for checkBurn, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    let burnReceipt = await provider.getTransactionReceipt(burnHash);
    // If no receipt, check that the transaction hasn't been replaced (speedup or canceled)
    if (!burnReceipt) {
        if (!transfer.ethCache)
            return transfer;
        try {
            const tx = {
                nonce: transfer.ethCache.nonce,
                from: transfer.ethCache.from,
                to: transfer.ethCache.to,
                data: transfer.ethCache.data
            };
            const foundTx = await find_replacement_tx_1.findReplacementTx(provider, transfer.ethCache.safeReorgHeight, tx);
            if (!foundTx)
                return transfer;
            burnReceipt = await provider.getTransactionReceipt(foundTx.hash);
        }
        catch (error) {
            console.error(error);
            if (error instanceof find_replacement_tx_1.TxValidationError) {
                return {
                    ...transfer,
                    errors: [...transfer.errors, error.message],
                    status: status.FAILED
                };
            }
            throw error;
        }
    }
    if (!burnReceipt)
        return transfer;
    if (!burnReceipt.status) {
        const error = `Transaction failed: ${burnReceipt.transactionHash}`;
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, error],
            burnReceipts: [...transfer.burnReceipts, burnReceipt]
        };
    }
    if (burnReceipt.transactionHash !== burnHash) {
        // Record the replacement tx burnHash
        transfer = {
            ...transfer,
            burnHashes: [...transfer.burnHashes, burnReceipt.transactionHash]
        };
    }
    const txBlock = await provider.getBlock(burnReceipt.blockHash);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        completedStep: BURN,
        startTime: new Date(txBlock.timestamp * 1000).toISOString(),
        burnReceipts: [...transfer.burnReceipts, burnReceipt]
    };
}
exports.checkBurn = checkBurn;
async function checkSync(transfer, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (typeof transfer === 'string') {
        return await recover(transfer, options);
    }
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_1.getEthProvider();
    const nearAccount = (_b = options.nearAccount) !== null && _b !== void 0 ? _b : await utils_1.getNearAccount();
    if (!transfer.checkSyncInterval) {
        // checkSync every 20s: reasonable value to show the confirmation counter x/30
        transfer = {
            ...transfer,
            checkSyncInterval: (_c = options.sendToNearSyncInterval) !== null && _c !== void 0 ? _c : bridgeParams.sendToNearSyncInterval
        };
    }
    if (transfer.nextCheckSyncTimestamp && new Date() < new Date(transfer.nextCheckSyncTimestamp)) {
        return transfer;
    }
    const burnReceipt = last(transfer.burnReceipts);
    const eventEmittedAt = burnReceipt.blockNumber;
    const syncedTo = await utils_2.ethOnNearSyncHeight((_d = options.nearClientAccount) !== null && _d !== void 0 ? _d : bridgeParams.nearClientAccount, nearAccount);
    const completedConfirmations = Math.max(0, syncedTo - eventEmittedAt);
    let proof;
    if (completedConfirmations > transfer.neededConfirmations) {
        // Check if relayer already minted
        proof = await utils_2.findEthProof('TransferToNearInitiated', burnReceipt.transactionHash, (_e = options.eNEARAddress) !== null && _e !== void 0 ? _e : bridgeParams.eNEARAddress, (_f = options.eNEARAbi) !== null && _f !== void 0 ? _f : bridgeParams.eNEARAbi, provider);
        const proofAlreadyUsed = await nearAccount.viewFunction((_g = options.nativeNEARLockerAddress) !== null && _g !== void 0 ? _g : bridgeParams.nativeNEARLockerAddress, 'is_used_proof', Buffer.from(proof), { stringify: (args) => args });
        if (proofAlreadyUsed) {
            if (options.callIndexer) {
                try {
                    const { transactions, timestamps } = await utils_2.findFinalizationTxOnNear({
                        proof: Buffer.from(proof).toString('base64'),
                        connectorAccount: (_h = options.nativeNEARLockerAddress) !== null && _h !== void 0 ? _h : bridgeParams.nativeNEARLockerAddress,
                        eventRelayerAccount: (_j = options.eventRelayerAccount) !== null && _j !== void 0 ? _j : bridgeParams.eventRelayerAccount,
                        finalizationMethod: 'finalise_eth_to_near_transfer',
                        callIndexer: options.callIndexer
                    });
                    let finishTime;
                    if (timestamps.length > 0) {
                        finishTime = new Date(timestamps[0] / 10 ** 6).toISOString();
                    }
                    transfer = {
                        ...transfer,
                        finishTime,
                        unlockHashes: [...transfer.unlockHashes, ...transactions]
                    };
                }
                catch (error) {
                    // Not finding the finalization tx should not prevent processing/recovering the transfer.
                    console.error(error);
                }
            }
            return {
                ...transfer,
                completedStep: UNLOCK,
                completedConfirmations,
                status: status.COMPLETE,
                errors: [...transfer.errors, 'Transfer already finalized.']
            };
        }
    }
    const nearEventRelayerMargin = (_k = options.nearEventRelayerMargin) !== null && _k !== void 0 ? _k : bridgeParams.nearEventRelayerMargin;
    if (completedConfirmations < transfer.neededConfirmations + nearEventRelayerMargin) {
        // Leave some time for the relayer to finalize
        return {
            ...transfer,
            nextCheckSyncTimestamp: new Date(Date.now() + transfer.checkSyncInterval),
            completedConfirmations,
            status: status.IN_PROGRESS
        };
    }
    return {
        ...transfer,
        completedConfirmations,
        completedStep: SYNC,
        status: status.ACTION_NEEDED,
        proof // used when checkSync() is called by mint()
    };
}
exports.checkSync = checkSync;
/**
 * Unlock NEAR tokens to transfer.recipient. Causes a redirect to NEAR Wallet,
 * currently dealt with using URL params.
 */
async function unlock(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_1.getBridgeParams();
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_1.getNearAccount();
    // Check if the transfer is finalized and get the proof if not
    transfer = await checkSync(transfer, options);
    if (transfer.status !== status.ACTION_NEEDED)
        return transfer;
    const proof = transfer.proof;
    // NOTE:
    // checkStatus should wait for NEAR wallet redirect if it didn't happen yet.
    // On page load the dapp should clear urlParams if transactionHashes or errorCode are not present:
    // this will allow checkStatus to handle the transfer as failed because the NEAR transaction could not be processed.
    if (typeof window !== 'undefined')
        utils_2.urlParams.set({ unlocking: transfer.id });
    if (typeof window !== 'undefined')
        transfer = await client_1.track({ ...transfer, status: status.IN_PROGRESS });
    const tx = await nearAccount.functionCall({
        contractId: (_b = options.nativeNEARLockerAddress) !== null && _b !== void 0 ? _b : bridgeParams.nativeNEARLockerAddress,
        methodName: 'finalise_eth_to_near_transfer',
        args: proof,
        // 200Tgas: enough for execution, not too much so that a 2fa tx is within 300Tgas
        gas: new bn_js_1.default('200' + '0'.repeat(12)),
        attachedDeposit: new bn_js_1.default('100000000000000000000').mul(new bn_js_1.default('600'))
    });
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        unlockHashes: [...transfer.unlockHashes, tx.transaction.hash]
    };
}
exports.unlock = unlock;
/**
 * Process a broadcasted unlock transaction
 * checkUnlock is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkUnlock can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
async function checkUnlock(transfer, options) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const id = utils_2.urlParams.get('unlocking');
    // NOTE: when a single tx is executed, transactionHashes is equal to that hash
    const txHash = utils_2.urlParams.get('transactionHashes');
    const errorCode = utils_2.urlParams.get('errorCode');
    const clearParams = ['unlocking', 'transactionHashes', 'errorCode', 'errorMessage'];
    if (!id) {
        // The user closed the tab and never rejected or approved the tx from Near wallet.
        // This doesn't protect agains the user broadcasting a tx and closing the tab before
        // redirect. So the dapp has no way of knowing the status of that transaction.
        // Set status to FAILED so that it can be retried
        const newError = `A finalization transaction was initiated but could not be verified.
      Click 'Retry' to make sure the transfer is finalized.`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (id !== transfer.id) {
        // Another unlocking transaction cannot be in progress, ie if checkUnlock is called on
        // an in progess unlock then the transfer ids must be equal or the url callback is invalid.
        const newError = `Couldn't determine transaction outcome.
      Got transfer id '${id} in URL, expected '${transfer.id}`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (errorCode) {
        // If errorCode, then the redirect succeded but the tx was rejected/failed
        // so clear url params
        utils_2.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: ' + errorCode;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (!txHash) {
        // If checkUnlock is called before unlock sig wallet redirect,
        // log the error but don't mark as FAILED and don't clear url params
        // as the wallet redirect has not happened yet
        const newError = 'Tx hash not received: pending redirect or wallet error';
        console.log(newError);
        return transfer;
    }
    if (txHash.includes(',')) {
        utils_2.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: expected single txHash, got: ' + txHash;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    const decodedTxHash = near_api_js_1.utils.serialize.base_decode(txHash);
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_1.getNearAccount();
    const unlockTx = await nearAccount.connection.provider.txStatus(decodedTxHash, nearAccount.accountId);
    // @ts-expect-error : wallet returns errorCode
    if (unlockTx.status.Unknown) {
        // Transaction or receipt not processed yet
        return transfer;
    }
    // Check status of tx broadcasted by wallet
    // @ts-expect-error : wallet returns errorCode
    if (unlockTx.status.Failure) {
        utils_2.urlParams.clear(...clearParams);
        const error = `NEAR transaction failed: ${txHash}`;
        console.error(error);
        return {
            ...transfer,
            errors: [...transfer.errors, error],
            status: status.FAILED,
            unlockHashes: [...transfer.unlockHashes, txHash]
        };
    }
    // Clear urlParams at the end so that if the provider connection throws,
    // checkStatus will be able to process it again in the next loop.
    utils_2.urlParams.clear(...clearParams);
    return {
        ...transfer,
        completedStep: UNLOCK,
        status: status.COMPLETE,
        unlockHashes: [...transfer.unlockHashes, txHash]
    };
}
exports.checkUnlock = checkUnlock;
const last = (arr) => arr[arr.length - 1];
//# sourceMappingURL=index.js.map