import { ethers } from 'ethers';
import { Account } from 'near-api-js';
import { TransferStatus, TransactionInfo } from '@near-eth/client/dist/types';
export declare const SOURCE_NETWORK = "ethereum";
export declare const DESTINATION_NETWORK = "near";
export declare const TRANSFER_TYPE = "@near-eth/near-ether/bridged-near/sendToNear";
export interface TransferDraft extends TransferStatus {
    type: string;
    burnHashes: string[];
    burnReceipts: ethers.providers.TransactionReceipt[];
    unlockHashes: string[];
    completedConfirmations: number;
    neededConfirmations: number;
}
export interface Transfer extends TransferDraft, TransactionInfo {
    id: string;
    startTime: string;
    finishTime?: string;
    decimals: number;
    destinationTokenName: string;
    recipient: string;
    sender: string;
    sourceTokenName: string;
    symbol: string;
    checkSyncInterval?: number;
    nextCheckSyncTimestamp?: Date;
    proof?: Uint8Array;
}
export interface TransferOptions {
    provider?: ethers.providers.JsonRpcProvider;
    eNEARAddress?: string;
    eNEARAbi?: string;
    nativeNEARLockerAddress?: string;
    sendToNearSyncInterval?: number;
    nearEventRelayerMargin?: number;
    nearAccount?: Account;
    nearClientAccount?: string;
    callIndexer?: (query: string) => Promise<Array<{
        originated_from_transaction_hash: string;
        included_in_block_timestamp: string;
    }>>;
    eventRelayerAccount?: string;
}
export declare const i18n: {
    en_US: {
        steps: (transfer: Transfer) => import("@near-eth/client/dist/types").Step[];
        statusMessage: (transfer: Transfer) => string;
        callToAction: (transfer: Transfer) => "Retry" | "Transfer" | "Deposit" | null;
    };
};
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
export declare function act(transfer: Transfer): Promise<Transfer>;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
export declare function checkStatus(transfer: Transfer): Promise<Transfer>;
/**
 * Find all burn transactions sending wNEAR back to NEAR.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.options Optional arguments.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.eNEARAddress ERC-20 NEAR on Ethereum address.
 * @param params.options.eNEARAbi ERC-20 NEAR on Ethereum abi.
 * @returns Array of Ethereum transaction hashes.
 */
export declare function findAllTransactions({ fromBlock, toBlock, sender, options }: {
    fromBlock: number | string;
    toBlock: number | string;
    sender: string;
    options?: {
        provider?: ethers.providers.Provider;
        eNEARAddress?: string;
        eNEARAbi?: string;
    };
}): Promise<string[]>;
/**
 * Recover all transfers sending wNEAR back to Near.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock Ethereum block number.
 * @param params.toBlock 'latest' | Ethereum block number.
 * @param params.sender Ethereum address.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
export declare function findAllTransfers({ fromBlock, toBlock, sender, options }: {
    fromBlock: number | string;
    toBlock: number | string;
    sender: string;
    options?: TransferOptions;
}): Promise<Transfer[]>;
/**
 * Recover transfer from a burn tx hash
 * Track a new transfer at the completedStep = BURN so that it can be unlocked
 * @param burnTxHash Ethereum transaction hash which initiated the transfer.
 * @param options TransferOptions optional arguments.
 * @returns The recovered transfer object
 */
export declare function recover(burnTxHash: string, options?: TransferOptions): Promise<Transfer>;
/**
 * Initiate a transfer from Ethereum to NEAR by burning bridged eNEAR tokens.
 * Broadcasts the burn transaction and creates a transfer object.
 * The receipt will be fetched by checkStatus.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient NEAR address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.sender Sender of tokens (defaults to the connected wallet address).
 * @param params.options.ethChainId Ethereum chain id of the bridge.
 * @param params.options.provider Ethereum provider to use.
 * @param params.options.eNEARAddress ERC-20 NEAR on Ethereum address.
 * @param params.options.eNEARAbi ERC-20 NEAR on Ethereum abi.
 * @param params.options.signer Ethers signer to use.
 * @returns The created transfer object.
 */
export declare function initiate({ amount, recipient, options }: {
    amount: string | ethers.BigNumber;
    recipient: string;
    options?: {
        sender?: string;
        ethChainId?: number;
        provider?: ethers.providers.JsonRpcProvider;
        eNEARAddress?: string;
        eNEARAbi?: string;
        signer?: ethers.Signer;
    };
}): Promise<Transfer>;
/**
 * Initiate "burn" transaction.
 * Only wait for transaction to have dependable transactionHash created. Avoid
 * blocking to wait for transaction to be mined. Status of transactionHash
 * being mined is then checked in checkStatus.
 */
export declare function burn(transfer: Transfer, options?: {
    provider?: ethers.providers.JsonRpcProvider;
    ethChainId?: number;
    eNEARAddress?: string;
    eNEARAbi?: string;
    signer?: ethers.Signer;
}): Promise<Transfer>;
export declare function checkBurn(transfer: Transfer, options?: {
    provider?: ethers.providers.Provider;
    ethChainId?: number;
}): Promise<Transfer>;
export declare function checkSync(transfer: Transfer | string, options?: TransferOptions): Promise<Transfer>;
/**
 * Unlock NEAR tokens to transfer.recipient. Causes a redirect to NEAR Wallet,
 * currently dealt with using URL params.
 */
export declare function unlock(transfer: Transfer | string, options?: TransferOptions): Promise<Transfer>;
/**
 * Process a broadcasted unlock transaction
 * checkUnlock is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkUnlock can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
export declare function checkUnlock(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
//# sourceMappingURL=index.d.ts.map