import { ethers } from 'ethers';
import { Account } from 'near-api-js';
import { FinalExecutionOutcome } from 'near-api-js/lib/providers';
import { TransferStatus, TransactionInfo } from '@near-eth/client/dist/types';
export declare const SOURCE_NETWORK = "near";
export declare const DESTINATION_NETWORK = "ethereum";
export declare const TRANSFER_TYPE = "@near-eth/near-ether/natural-near/sendToEthereum";
export interface TransferDraft extends TransferStatus {
    type: string;
    finalityBlockHeights: number[];
    nearOnEthClientBlockHeight: null | number;
    mintHashes: string[];
    mintReceipts: ethers.providers.TransactionReceipt[];
    lockHashes: string[];
    lockReceiptBlockHeights: number[];
    lockReceiptIds: string[];
}
export interface Transfer extends TransferDraft, TransactionInfo {
    id: string;
    startTime: string;
    finishTime?: string;
    decimals: number;
    destinationTokenName: string;
    recipient: string;
    sender: string;
    sourceTokenName: string;
    symbol: string;
    checkSyncInterval?: number;
    nextCheckSyncTimestamp?: Date;
    proof?: Uint8Array;
}
export interface TransferOptions {
    provider?: ethers.providers.Provider;
    eNEARAddress?: string;
    eNEARAbi?: string;
    sendToEthereumSyncInterval?: number;
    ethChainId?: number;
    nearAccount?: Account;
    ethClientAddress?: string;
    ethClientAbi?: string;
    nativeNEARLockerAddress?: string;
}
export declare const i18n: {
    en_US: {
        steps: (transfer: Transfer) => import("@near-eth/client/dist/types").Step[];
        statusMessage: (transfer: Transfer) => "Failed" | "Ready to transfer from NEAR" | "Ready to deposit in Ethereum" | "Transfering to Ethereum" | "Confirming transfer" | "Depositing in Ethereum" | "Transfer complete";
        callToAction: (transfer: Transfer) => "Retry" | "Transfer" | "Deposit" | null;
    };
};
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
export declare function act(transfer: Transfer): Promise<Transfer>;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
export declare function checkStatus(transfer: Transfer): Promise<Transfer>;
/**
 * Find all lock transactions sending NEAR to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options Optional arguments.
 * @param params.options.nativeNEARLockerAddress $NEAR bridge connector address on NEAR.
 * @returns Array of NEAR transaction hashes.
 */
export declare function findAllTransactions({ fromBlock, toBlock, sender, callIndexer, options }: {
    fromBlock: string;
    toBlock: string;
    sender: string;
    callIndexer: (query: string) => Promise<[{
        originated_from_transaction_hash: string;
        args: {
            method_name: string;
        };
    }]>;
    options?: {
        nativeNEARLockerAddress?: string;
    };
}): Promise<string[]>;
/**
 * Recover all transfers sending NEAR to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
export declare function findAllTransfers({ fromBlock, toBlock, sender, callIndexer, options }: {
    fromBlock: string;
    toBlock: string;
    sender: string;
    callIndexer: (query: string) => Promise<[{
        originated_from_transaction_hash: string;
        args: {
            method_name: string;
        };
    }]>;
    options?: TransferOptions;
}): Promise<Transfer[]>;
/**
 * Recover transfer from a lock tx hash.
 * @param lockTxHash Near tx hash containing the token lock.
 * @param sender Near account sender of lockTxHash.
 * @param options TransferOptions optional arguments.
 * @returns The created transfer object.
 */
export declare function recover(lockTxHash: string, sender?: string, options?: TransferOptions): Promise<Transfer>;
/**
 * Parse the lock receipt id and block height needed to complete
 * the step LOCK
 * @param lockTx
 * @param sender
 * @param nativeNEARLockerAddress
 * @param nearAccount
 */
export declare function parseLockReceipt(lockTx: FinalExecutionOutcome, sender: string, nativeNEARLockerAddress: string, nearAccount: Account): Promise<{
    id: string;
    blockHeight: number;
}>;
/**
 * Initiate a transfer from NEAR to Ethereum by locking $NEAR tokens.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient Ethereum address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.sender Sender of tokens (defaults to the connected NEAR wallet address).
 * @param params.options.nativeNEARLockerAddress $NEAR bridge connector address on NEAR.
 * @param params.options.nearAccount Connected NEAR wallet account to use.
 * @returns The created transfer object.
 */
export declare function initiate({ amount, recipient, options }: {
    amount: string | ethers.BigNumber;
    recipient: string;
    options?: {
        sender?: string;
        nativeNEARLockerAddress?: string;
        nearAccount?: Account;
    };
}): Promise<Transfer>;
/**
 * Lock native NEAR to migrate to Ethereum.
 */
export declare function lock(transfer: Transfer, options?: {
    nativeNEARLockerAddress?: string;
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Process a broadcasted lock transaction
 * checkLock is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkLock can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
export declare function checkLock(transfer: Transfer, options?: {
    nativeNEARLockerAddress?: string;
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Wait for a final block with a strictly greater height than lockTx
 * receipt. This block (or one of its ancestors) should hold the outcome.
 * Although this may not support sharding.
 * TODO: support sharding
 */
export declare function checkFinality(transfer: Transfer, options?: {
    nearAccount?: Account;
}): Promise<Transfer>;
/**
 * Wait for the block with the given receipt/transaction in Near2EthClient, and
 * get the outcome proof only use block merkle root that we know is available
 * on the Near2EthClient.
 */
export declare function checkSync(transfer: Transfer | string, options?: TransferOptions): Promise<Transfer>;
/**
 * Check if a NEAR outcome receipt_id has already been used to finalize a transfer to Ethereum.
 */
export declare function proofAlreadyUsed(provider: ethers.providers.Provider, proof: any, eNEARAddress: string, eNEARAbi: string): Promise<boolean>;
/**
 * Mint eNEAR tokens,
 * passing the proof that the tokens were locked in the corresponding
 * NEAR BridgeToken contract.
 */
export declare function mint(transfer: Transfer | string, options?: Omit<TransferOptions, 'provider'> & {
    provider?: ethers.providers.JsonRpcProvider;
    signer?: ethers.Signer;
}): Promise<Transfer>;
export declare function checkMint(transfer: Transfer, options?: {
    provider?: ethers.providers.Provider;
    ethChainId?: number;
}): Promise<Transfer>;
//# sourceMappingURL=index.d.ts.map