"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkMint = exports.mint = exports.proofAlreadyUsed = exports.checkSync = exports.checkFinality = exports.checkLock = exports.lock = exports.initiate = exports.parseLockReceipt = exports.recover = exports.findAllTransfers = exports.findAllTransactions = exports.checkStatus = exports.act = exports.i18n = exports.TRANSFER_TYPE = exports.DESTINATION_NETWORK = exports.SOURCE_NETWORK = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bs58_1 = __importDefault(require("bs58"));
const ethers_1 = require("ethers");
const near_api_js_1 = require("near-api-js");
const serialize_1 = require("near-api-js/lib/utils/serialize");
const status = __importStar(require("@near-eth/client/dist/statuses"));
const i18nHelpers_1 = require("@near-eth/client/dist/i18nHelpers");
const client_1 = require("@near-eth/client");
const utils_1 = require("@near-eth/utils");
const utils_2 = require("@near-eth/client/dist/utils");
const find_replacement_tx_1 = require("find-replacement-tx");
exports.SOURCE_NETWORK = 'near';
exports.DESTINATION_NETWORK = 'ethereum';
exports.TRANSFER_TYPE = '@near-eth/near-ether/natural-near/sendToEthereum';
const LOCK = 'lock-natural-near-to-e-near';
const AWAIT_FINALITY = 'await-finality-natural-near-to-e-near';
const SYNC = 'sync-natural-near-to-e-near';
const MINT = 'mint-natural-near-to-e-near';
const steps = [
    LOCK,
    AWAIT_FINALITY,
    SYNC,
    MINT
];
class TransferError extends Error {
}
const transferDraft = {
    // Attributes common to all transfer types
    // amount,
    completedStep: null,
    // destinationTokenName,
    errors: [],
    // recipient,
    // sender,
    // sourceToken,
    // sourceTokenName,
    // decimals,
    status: status.IN_PROGRESS,
    type: exports.TRANSFER_TYPE,
    // Cache eth tx information used for finding a replaced (speedup/cancel) tx.
    // ethCache: {
    //   from,                     // tx.from of last broadcasted eth tx
    //   to,                       // tx.to of last broadcasted eth tx (can be multisig contract)
    //   safeReorgHeight,          // Lower boundary for replacement tx search
    //   nonce                     // tx.nonce of last broadcasted eth tx
    // }
    // Attributes specific to bridged-nep141-to-erc20 transfers
    finalityBlockHeights: [],
    nearOnEthClientBlockHeight: null,
    mintHashes: [],
    mintReceipts: [],
    lockReceiptBlockHeights: [],
    lockReceiptIds: [],
    lockHashes: []
};
/* eslint-disable @typescript-eslint/restrict-template-expressions */
exports.i18n = {
    en_US: {
        steps: (transfer) => i18nHelpers_1.stepsFor(transfer, steps, {
            [LOCK]: `Start transfer of ${utils_2.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.sourceTokenName} from NEAR`,
            [AWAIT_FINALITY]: 'Confirm in NEAR',
            [SYNC]: 'Confirm in Ethereum. This can take around 16 hours. Feel free to return to this window later, to complete the final step of the transfer.',
            [MINT]: `Deposit ${utils_2.formatLargeNum(transfer.amount, transfer.decimals).toString()} ${transfer.destinationTokenName} in Ethereum`
        }),
        statusMessage: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Failed';
            if (transfer.status === status.ACTION_NEEDED) {
                switch (transfer.completedStep) {
                    case null: return 'Ready to transfer from NEAR';
                    case SYNC: return 'Ready to deposit in Ethereum';
                    default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
                }
            }
            switch (transfer.completedStep) {
                case null: return 'Transfering to Ethereum';
                case LOCK: return 'Confirming transfer';
                case AWAIT_FINALITY: return 'Confirming transfer';
                case SYNC: return 'Depositing in Ethereum';
                case MINT: return 'Transfer complete';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        },
        callToAction: (transfer) => {
            if (transfer.status === status.FAILED)
                return 'Retry';
            if (transfer.status !== status.ACTION_NEEDED)
                return null;
            switch (transfer.completedStep) {
                case null: return 'Transfer';
                case SYNC: return 'Deposit';
                default: throw new Error(`Transfer in unexpected state, transfer with ID=${transfer.id} & status=${transfer.status} has completedStep=${transfer.completedStep}`);
            }
        }
    }
};
/* eslint-enable @typescript-eslint/restrict-template-expressions */
/**
 * Called when status is ACTION_NEEDED or FAILED
 * @param transfer Transfer object to act on.
 */
async function act(transfer) {
    switch (transfer.completedStep) {
        case null:
            try {
                return await lock(transfer);
            }
            catch (error) {
                console.error(error);
                if (error.message.includes('Failed to redirect to sign transaction')) {
                    // Increase time to redirect to wallet before recording an error
                    await new Promise(resolve => setTimeout(resolve, 10000));
                }
                if (typeof window !== 'undefined')
                    utils_1.urlParams.clear('locking');
                throw error;
            }
        case AWAIT_FINALITY: return await checkSync(transfer);
        case SYNC: return await mint(transfer);
        default: throw new Error(`Don't know how to act on transfer: ${JSON.stringify(transfer)}`);
    }
}
exports.act = act;
/**
 * Called when status is IN_PROGRESS
 * @param transfer Transfer object to check status on.
 */
async function checkStatus(transfer) {
    switch (transfer.completedStep) {
        case null: return await checkLock(transfer);
        case LOCK: return await checkFinality(transfer);
        case AWAIT_FINALITY: return await checkSync(transfer);
        case SYNC: return await checkMint(transfer);
        default: throw new Error(`Don't know how to checkStatus for transfer ${transfer.id}`);
    }
}
exports.checkStatus = checkStatus;
/**
 * Find all lock transactions sending NEAR to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options Optional arguments.
 * @param params.options.nativeNEARLockerAddress $NEAR bridge connector address on NEAR.
 * @returns Array of NEAR transaction hashes.
 */
async function findAllTransactions({ fromBlock, toBlock, sender, callIndexer, options }) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const nativeNEARLockerAddress = (_a = options.nativeNEARLockerAddress) !== null && _a !== void 0 ? _a : bridgeParams.nativeNEARLockerAddress;
    const transactions = await callIndexer(utils_1.buildIndexerTxQuery({ fromBlock, toBlock, predecessorAccountId: sender, receiverAccountId: nativeNEARLockerAddress }));
    return transactions.filter(tx => tx.args.method_name === 'migrate_to_ethereum').map(tx => tx.originated_from_transaction_hash);
}
exports.findAllTransactions = findAllTransactions;
/**
 * Recover all transfers sending NEAR to Ethereum.
 * Any WAMP library can be used to query the indexer or near explorer backend via the `callIndexer` callback.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.fromBlock NEAR block timestamp.
 * @param params.toBlock 'latest' | NEAR block timestamp.
 * @param params.sender NEAR account id.
 * @param params.callIndexer Function making the query to indexer.
 * @param params.options TransferOptions.
 * @returns Array of recovered transfers.
 */
async function findAllTransfers({ fromBlock, toBlock, sender, callIndexer, options }) {
    const burnTransactions = await findAllTransactions({ fromBlock, toBlock, sender, callIndexer, options });
    const transfers = await Promise.all(burnTransactions.map(async (tx) => {
        try {
            return await recover(tx, sender, options);
        }
        catch (error) {
            // Unlike with Ethereum events, the transaction exists even if it failed.
            // So ignore the transfer if it cannot be recovered
            console.log('Failed to recover transfer (transaction failed ?): ', tx, error);
            return null;
        }
    }));
    return transfers.filter((transfer) => transfer !== null);
}
exports.findAllTransfers = findAllTransfers;
/**
 * Recover transfer from a lock tx hash.
 * @param lockTxHash Near tx hash containing the token lock.
 * @param sender Near account sender of lockTxHash.
 * @param options TransferOptions optional arguments.
 * @returns The created transfer object.
 */
async function recover(lockTxHash, sender = 'todo', options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    const decodedTxHash = near_api_js_1.utils.serialize.base_decode(lockTxHash);
    const lockTx = await nearAccount.connection.provider.txStatus(
    // TODO: when multiple shards, the sender should be known in order to query txStatus
    decodedTxHash, sender);
    sender = lockTx.transaction.signer_id;
    // @ts-expect-error TODO
    if (lockTx.status.Unknown) {
        // Transaction or receipt not processed yet
        throw new Error(`Lock transaction pending: ${lockTxHash}`);
    }
    // @ts-expect-error TODO
    if (lockTx.status.Failure) {
        throw new Error(`Lock transaction failed: ${lockTxHash}`);
    }
    // Get lock event information from successValue
    // @ts-expect-error TODO
    const successValue = lockTx.status.SuccessValue;
    if (!successValue) {
        throw new Error(`Invalid lockTx successValue: '${successValue}'
      Full lock transaction: ${JSON.stringify(lockTx)}`);
    }
    // eslint-disable-next-line @typescript-eslint/no-extraneous-class
    class LockEvent {
        constructor(args) {
            Object.assign(this, args);
        }
    }
    const SCHEMA = new Map([
        [LockEvent, {
                kind: 'struct',
                fields: [
                    ['flag', 'u8'],
                    ['amount', 'u128'],
                    ['recipient', [20]]
                ]
            }]
    ]);
    const lockEvent = serialize_1.deserialize(SCHEMA, LockEvent, Buffer.from(successValue, 'base64'));
    const amount = lockEvent.amount.toString();
    const recipient = '0x' + Buffer.from(lockEvent.recipient).toString('hex');
    const symbol = 'NEAR';
    const destinationTokenName = symbol;
    const sourceTokenName = symbol;
    const sourceToken = symbol;
    const decimals = 24;
    const lockReceipt = await parseLockReceipt(lockTx, sender, (_b = options.nativeNEARLockerAddress) !== null && _b !== void 0 ? _b : bridgeParams.nativeNEARLockerAddress, nearAccount);
    // @ts-expect-error TODO
    const txBlock = await nearAccount.connection.provider.block({ blockId: lockTx.transaction_outcome.block_hash });
    // various attributes stored as arrays, to keep history of retries
    const transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date(txBlock.header.timestamp / 10 ** 6).toISOString(),
        amount,
        completedStep: LOCK,
        destinationTokenName,
        recipient,
        sender,
        sourceTokenName,
        symbol,
        sourceToken,
        decimals,
        lockHashes: [lockTxHash],
        lockReceiptBlockHeights: [lockReceipt.blockHeight],
        lockReceiptIds: [lockReceipt.id]
    };
    // Check transfer status
    return await checkSync(transfer, options);
}
exports.recover = recover;
/**
 * Parse the lock receipt id and block height needed to complete
 * the step LOCK
 * @param lockTx
 * @param sender
 * @param nativeNEARLockerAddress
 * @param nearAccount
 */
async function parseLockReceipt(lockTx, sender, nativeNEARLockerAddress, nearAccount) {
    const receiptIds = lockTx.transaction_outcome.outcome.receipt_ids;
    if (receiptIds.length !== 1) {
        throw new TransferError(`Lock expects only one receipt, got ${receiptIds.length}.
      Full lock transaction: ${JSON.stringify(lockTx)}`);
    }
    // Get receipt information for recording and building lock proof
    const txReceiptId = receiptIds[0];
    const successReceiptOutcome = lockTx.receipts_outcome
        .find(r => r.id === txReceiptId)
        .outcome;
    // @ts-expect-error TODO
    const successReceiptId = successReceiptOutcome.status.SuccessReceiptId;
    // @ts-expect-error TODO
    const successReceiptExecutorId = successReceiptOutcome.executor_id;
    let lockReceiptId;
    // Check if this tx was made from a 2fa
    switch (successReceiptExecutorId) {
        case sender: {
            // `confirm` transaction executed on 2fa account
            const lockReceiptOutcome = lockTx.receipts_outcome
                .find(r => r.id === successReceiptId)
                .outcome;
            lockReceiptId = successReceiptId;
            // @ts-expect-error TODO
            const lockReceiptExecutorId = lockReceiptOutcome.executor_id;
            // Expect this receipt to be the 2fa FunctionCall
            if (lockReceiptExecutorId !== nativeNEARLockerAddress) {
                throw new TransferError(`Unexpected receipt outcome format in 2fa transaction.
          Expected nativeNEARLockerAddress '${nativeNEARLockerAddress}', got '${lockReceiptExecutorId}'
          Full withdrawal transaction: ${JSON.stringify(lockTx)}`);
            }
            break;
        }
        case nativeNEARLockerAddress:
            // `lock` called directly, successReceiptId is already correct, nothing to do
            lockReceiptId = txReceiptId;
            break;
        default:
            throw new TransferError(`Unexpected receipt outcome format.
        Full withdrawal transaction: ${JSON.stringify(lockTx)}`);
    }
    const txReceiptBlockHash = lockTx.receipts_outcome
        .find(r => r.id === lockReceiptId)
        // @ts-expect-error TODO
        .block_hash;
    const receiptBlock = await nearAccount.connection.provider.block({
        blockId: txReceiptBlockHash
    });
    const receiptBlockHeight = Number(receiptBlock.header.height);
    return { id: lockReceiptId, blockHeight: receiptBlockHeight };
}
exports.parseLockReceipt = parseLockReceipt;
/**
 * Initiate a transfer from NEAR to Ethereum by locking $NEAR tokens.
 * @param params Uses Named Arguments pattern, please pass arguments as object
 * @param params.amount Number of tokens to transfer.
 * @param params.recipient Ethereum address to receive tokens on the other side of the bridge.
 * @param params.options Optional arguments.
 * @param params.options.sender Sender of tokens (defaults to the connected NEAR wallet address).
 * @param params.options.nativeNEARLockerAddress $NEAR bridge connector address on NEAR.
 * @param params.options.nearAccount Connected NEAR wallet account to use.
 * @returns The created transfer object.
 */
async function initiate({ amount, recipient, options }) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const symbol = 'NEAR';
    const destinationTokenName = symbol;
    const sourceTokenName = symbol;
    const sourceToken = symbol;
    const decimals = 24;
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    const sender = (_b = options.sender) !== null && _b !== void 0 ? _b : nearAccount.accountId;
    // various attributes stored as arrays, to keep history of retries
    let transfer = {
        ...transferDraft,
        id: Math.random().toString().slice(2),
        startTime: new Date().toISOString(),
        amount: amount.toString(),
        destinationTokenName,
        recipient,
        sender,
        sourceTokenName,
        symbol,
        sourceToken,
        decimals
    };
    try {
        transfer = await lock(transfer, options);
    }
    catch (error) {
        if (error.message.includes('Failed to redirect to sign transaction')) {
            // Increase time to redirect to wallet before alerting an error
            await new Promise(resolve => setTimeout(resolve, 10000));
        }
        if (typeof window !== 'undefined' && utils_1.urlParams.get('locking')) {
            // If the urlParam is set then the transfer was tracked so delete it.
            await client_1.untrack(utils_1.urlParams.get('locking'));
            utils_1.urlParams.clear('locking');
        }
        // Throw the error to be handled by frontend
        throw error;
    }
    return transfer;
}
exports.initiate = initiate;
/**
 * Lock native NEAR to migrate to Ethereum.
 */
async function lock(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    // NOTE:
    // checkStatus should wait for NEAR wallet redirect if it didn't happen yet.
    // On page load the dapp should clear urlParams if transactionHashes or errorCode are not present:
    // this will allow checkStatus to handle the transfer as failed because the NEAR transaction could not be processed.
    if (typeof window !== 'undefined')
        utils_1.urlParams.set({ locking: transfer.id });
    if (typeof window !== 'undefined')
        transfer = await client_1.track({ ...transfer, status: status.IN_PROGRESS });
    const tx = await nearAccount.functionCall({
        contractId: (_b = options.nativeNEARLockerAddress) !== null && _b !== void 0 ? _b : bridgeParams.nativeNEARLockerAddress,
        methodName: 'migrate_to_ethereum',
        args: {
            eth_recipient: transfer.recipient.replace('0x', '')
        },
        gas: new bn_js_1.default('10' + '0'.repeat(12)),
        attachedDeposit: new bn_js_1.default(transfer.amount)
    });
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        lockHashes: [...transfer.lockHashes, tx.transaction.hash]
    };
}
exports.lock = lock;
/**
 * Process a broadcasted lock transaction
 * checkLock is called in a loop by checkStatus for in progress transfers
 * urlParams should be cleared only if the transaction succeded or if it FAILED
 * Otherwise if this function throws due to provider or returns, then urlParams
 * should not be cleared so that checkLock can try again at the next loop.
 * So urlparams.clear() is called when status.FAILED or at the end of this function.
 */
async function checkLock(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const id = utils_1.urlParams.get('locking');
    // NOTE: when a single tx is executed, transactionHashes is equal to that hash
    const txHash = utils_1.urlParams.get('transactionHashes');
    const errorCode = utils_1.urlParams.get('errorCode');
    const clearParams = ['locking', 'transactionHashes', 'errorCode', 'errorMessage'];
    if (!id) {
        // The user closed the tab and never rejected or approved the tx from Near wallet.
        // This doesn't protect agains the user broadcasting a tx and closing the tab before
        // redirect. So the dapp has no way of knowing the status of that transaction.
        // Set status to FAILED so that it can be retried
        const newError = `A transaction was initiated but could not be verified.
      Click 'Rescan the blockchain' to check if a transfer was created.`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (id !== transfer.id) {
        // Another lock transaction cannot be in progress, ie if checkLock is called on
        // an in process lock then the transfer ids must be equal or the url callback is invalid.
        const newError = `Couldn't determine transaction outcome.
      Got transfer id '${id} in URL, expected '${transfer.id}`;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (errorCode) {
        // If errorCode, then the redirect succeded but the tx was rejected/failed
        // so clear url params
        utils_1.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: ' + errorCode;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    if (!txHash) {
        // If checkLock is called before lock sig wallet redirect
        // log the error but don't mark as FAILED and don't clear url params
        // as the wallet redirect has not happened yet
        const newError = 'Lock tx hash not received: pending redirect or wallet error';
        console.log(newError);
        return transfer;
    }
    if (txHash.includes(',')) {
        utils_1.urlParams.clear(...clearParams);
        const newError = 'Error from wallet: expected single txHash, got: ' + txHash;
        console.error(newError);
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, newError]
        };
    }
    const decodedTxHash = near_api_js_1.utils.serialize.base_decode(txHash);
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    const lockTx = await nearAccount.connection.provider.txStatus(
    // use transfer.sender instead of nearAccount.accountId so that a lock
    // tx hash can be recovered even if it is not made by the logged in account
    decodedTxHash, transfer.sender);
    // @ts-expect-error : wallet returns errorCode
    if (lockTx.status.Unknown) {
        // Transaction or receipt not processed yet
        return transfer;
    }
    // Check status of tx broadcasted by wallet
    // @ts-expect-error : wallet returns errorCode
    if (lockTx.status.Failure) {
        utils_1.urlParams.clear(...clearParams);
        const error = `NEAR transaction failed: ${txHash}`;
        console.error(error);
        return {
            ...transfer,
            errors: [...transfer.errors, error],
            status: status.FAILED,
            lockHashes: [...transfer.lockHashes, txHash]
        };
    }
    let lockReceipt;
    try {
        lockReceipt = await parseLockReceipt(lockTx, transfer.sender, (_b = options.nativeNEARLockerAddress) !== null && _b !== void 0 ? _b : bridgeParams.nativeNEARLockerAddress, nearAccount);
    }
    catch (e) {
        if (e instanceof TransferError) {
            utils_1.urlParams.clear(...clearParams);
            return {
                ...transfer,
                errors: [...transfer.errors, e.message],
                status: status.FAILED,
                lockHashes: [...transfer.lockHashes, txHash]
            };
        }
        // Any other error like provider connection error should throw
        // so that the transfer stays in progress and checkLock will be called again.
        throw e;
    }
    // @ts-expect-error TODO
    const txBlock = await nearAccount.connection.provider.block({ blockId: lockTx.transaction_outcome.block_hash });
    const startTime = new Date(txBlock.header.timestamp / 10 ** 6).toISOString();
    // Clear urlParams at the end so that if the provider connection throws,
    // checkStatus will be able to process it again in the next loop.
    utils_1.urlParams.clear(...clearParams);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        completedStep: LOCK,
        startTime,
        lockReceiptIds: [...transfer.lockReceiptIds, lockReceipt.id],
        lockReceiptBlockHeights: [...transfer.lockReceiptBlockHeights, lockReceipt.blockHeight],
        lockHashes: [...transfer.lockHashes, txHash]
    };
}
exports.checkLock = checkLock;
/**
 * Wait for a final block with a strictly greater height than lockTx
 * receipt. This block (or one of its ancestors) should hold the outcome.
 * Although this may not support sharding.
 * TODO: support sharding
 */
async function checkFinality(transfer, options) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    const nearAccount = (_a = options.nearAccount) !== null && _a !== void 0 ? _a : await utils_2.getNearAccount();
    const lockReceiptBlockHeight = last(transfer.lockReceiptBlockHeights);
    const latestFinalizedBlock = Number((await nearAccount.connection.provider.block({ finality: 'final' })).header.height);
    if (latestFinalizedBlock <= lockReceiptBlockHeight) {
        return transfer;
    }
    return {
        ...transfer,
        completedStep: AWAIT_FINALITY,
        status: status.IN_PROGRESS,
        finalityBlockHeights: [...transfer.finalityBlockHeights, latestFinalizedBlock]
    };
}
exports.checkFinality = checkFinality;
/**
 * Wait for the block with the given receipt/transaction in Near2EthClient, and
 * get the outcome proof only use block merkle root that we know is available
 * on the Near2EthClient.
 */
async function checkSync(transfer, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    if (typeof transfer === 'string') {
        return await recover(transfer, 'todo', options);
    }
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_2.getEthProvider();
    if (!transfer.checkSyncInterval) {
        // checkSync every 60s: reasonable value to detect transfer is ready to be finalized
        transfer = {
            ...transfer,
            checkSyncInterval: (_b = options.sendToEthereumSyncInterval) !== null && _b !== void 0 ? _b : bridgeParams.sendToEthereumSyncInterval
        };
    }
    if (transfer.nextCheckSyncTimestamp && new Date() < new Date(transfer.nextCheckSyncTimestamp)) {
        return transfer;
    }
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_c = options.ethChainId) !== null && _c !== void 0 ? _c : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        throw new Error(`Wrong eth network for checkSync, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const lockReceiptBlockHeight = last(transfer.lockReceiptBlockHeights);
    const nearOnEthClientBlockHeight = await utils_1.nearOnEthSyncHeight(provider, (_d = options.ethClientAddress) !== null && _d !== void 0 ? _d : bridgeParams.ethClientAddress, (_e = options.ethClientAbi) !== null && _e !== void 0 ? _e : bridgeParams.ethClientAbi);
    let proof;
    const nearAccount = (_f = options.nearAccount) !== null && _f !== void 0 ? _f : await utils_2.getNearAccount();
    if (nearOnEthClientBlockHeight > lockReceiptBlockHeight) {
        proof = await utils_1.findNearProof(last(transfer.lockReceiptIds), (_g = options.nativeNEARLockerAddress) !== null && _g !== void 0 ? _g : bridgeParams.nativeNEARLockerAddress, nearOnEthClientBlockHeight, nearAccount, provider, (_h = options.ethClientAddress) !== null && _h !== void 0 ? _h : bridgeParams.ethClientAddress, (_j = options.ethClientAbi) !== null && _j !== void 0 ? _j : bridgeParams.ethClientAbi);
        if (await proofAlreadyUsed(provider, proof, (_k = options.eNEARAddress) !== null && _k !== void 0 ? _k : bridgeParams.eNEARAddress, (_l = options.eNEARAbi) !== null && _l !== void 0 ? _l : bridgeParams.eNEARAbi)) {
            try {
                const { transactions, block } = await utils_1.findFinalizationTxOnEthereum({
                    usedProofPosition: '8',
                    proof,
                    connectorAddress: (_m = options.eNEARAddress) !== null && _m !== void 0 ? _m : bridgeParams.eNEARAddress,
                    connectorAbi: (_o = options.eNEARAbi) !== null && _o !== void 0 ? _o : bridgeParams.eNEARAbi,
                    finalizationEvent: 'NearToEthTransferFinalised',
                    recipient: transfer.recipient,
                    amount: transfer.amount,
                    provider
                });
                transfer = {
                    ...transfer,
                    finishTime: new Date(block.timestamp * 1000).toISOString(),
                    mintHashes: [...transfer.mintHashes, ...transactions]
                };
            }
            catch (error) {
                // Not finding the finalization tx should not prevent processing/recovering the transfer.
                console.error(error);
            }
            return {
                ...transfer,
                completedStep: MINT,
                nearOnEthClientBlockHeight,
                status: status.COMPLETE,
                errors: [...transfer.errors, 'Mint proof already used.']
            };
        }
    }
    else {
        return {
            ...transfer,
            nextCheckSyncTimestamp: new Date(Date.now() + transfer.checkSyncInterval),
            nearOnEthClientBlockHeight,
            status: status.IN_PROGRESS
        };
    }
    return {
        ...transfer,
        completedStep: SYNC,
        nearOnEthClientBlockHeight,
        status: status.ACTION_NEEDED,
        proof // used when checkSync() is called by unlock()
    };
}
exports.checkSync = checkSync;
/**
 * Check if a NEAR outcome receipt_id has already been used to finalize a transfer to Ethereum.
 */
async function proofAlreadyUsed(provider, proof, eNEARAddress, eNEARAbi) {
    const eNEAR = new ethers_1.ethers.Contract(eNEARAddress, eNEARAbi, provider);
    const proofIsUsed = await eNEAR.usedProofs('0x' + bs58_1.default.decode(proof.outcome_proof.outcome.receipt_ids[0]).toString('hex'));
    return proofIsUsed;
}
exports.proofAlreadyUsed = proofAlreadyUsed;
/**
 * Mint eNEAR tokens,
 * passing the proof that the tokens were locked in the corresponding
 * NEAR BridgeToken contract.
 */
async function mint(transfer, options) {
    var _a, _b, _c, _d;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_2.getSignerProvider();
    // Build lock proof
    transfer = await checkSync(transfer, { ...options, provider });
    if (transfer.status !== status.ACTION_NEEDED)
        return transfer;
    const proof = transfer.proof;
    const borshProof = utils_1.borshifyOutcomeProof(proof);
    const eNEAR = new ethers_1.ethers.Contract((_b = options.eNEARAddress) !== null && _b !== void 0 ? _b : bridgeParams.eNEARAddress, (_c = options.eNEARAbi) !== null && _c !== void 0 ? _c : bridgeParams.eNEARAbi, (_d = options.signer) !== null && _d !== void 0 ? _d : provider.getSigner());
    // If this tx is dropped and replaced, lower the search boundary
    // in case there was a reorg.
    const safeReorgHeight = await provider.getBlockNumber() - 20;
    const pendingMintTx = await eNEAR.finaliseNearToEthTransfer(borshProof, transfer.nearOnEthClientBlockHeight);
    return {
        ...transfer,
        status: status.IN_PROGRESS,
        ethCache: {
            from: pendingMintTx.from,
            to: pendingMintTx.to,
            safeReorgHeight,
            data: pendingMintTx.data,
            nonce: pendingMintTx.nonce
        },
        mintHashes: [...transfer.mintHashes, pendingMintTx.hash]
    };
}
exports.mint = mint;
async function checkMint(transfer, options) {
    var _a, _b;
    options = options !== null && options !== void 0 ? options : {};
    const bridgeParams = utils_2.getBridgeParams();
    const provider = (_a = options.provider) !== null && _a !== void 0 ? _a : utils_2.getEthProvider();
    const ethChainId = (await provider.getNetwork()).chainId;
    const expectedChainId = (_b = options.ethChainId) !== null && _b !== void 0 ? _b : bridgeParams.ethChainId;
    if (ethChainId !== expectedChainId) {
        throw new Error(`Wrong eth network for checkMint, expected: ${expectedChainId}, got: ${ethChainId}`);
    }
    const mintHash = last(transfer.mintHashes);
    let mintReceipt = await provider.getTransactionReceipt(mintHash);
    // If no receipt, check that the transaction hasn't been replaced (speedup or canceled)
    if (!mintReceipt) {
        if (!transfer.ethCache)
            return transfer;
        try {
            const tx = {
                nonce: transfer.ethCache.nonce,
                from: transfer.ethCache.from,
                to: transfer.ethCache.to,
                data: transfer.ethCache.data
            };
            const foundTx = await find_replacement_tx_1.findReplacementTx(provider, transfer.ethCache.safeReorgHeight, tx);
            if (!foundTx)
                return transfer;
            mintReceipt = await provider.getTransactionReceipt(foundTx.hash);
        }
        catch (error) {
            console.error(error);
            if (error instanceof find_replacement_tx_1.TxValidationError) {
                return {
                    ...transfer,
                    errors: [...transfer.errors, error.message],
                    status: status.FAILED
                };
            }
            throw error;
        }
    }
    if (!mintReceipt)
        return transfer;
    if (!mintReceipt.status) {
        const error = `Transaction failed: ${mintReceipt.transactionHash}`;
        return {
            ...transfer,
            status: status.FAILED,
            errors: [...transfer.errors, error],
            mintReceipts: [...transfer.mintReceipts, mintReceipt]
        };
    }
    if (mintReceipt.transactionHash !== mintHash) {
        // Record the replacement tx mintHash
        return {
            ...transfer,
            status: status.COMPLETE,
            completedStep: MINT,
            mintHashes: [...transfer.mintHashes, mintReceipt.transactionHash],
            mintReceipts: [...transfer.mintReceipts, mintReceipt]
        };
    }
    const block = await provider.getBlock(mintReceipt.blockNumber);
    return {
        ...transfer,
        status: status.COMPLETE,
        completedStep: MINT,
        finishTime: new Date(block.timestamp * 1000).toISOString(),
        mintReceipts: [...transfer.mintReceipts, mintReceipt]
    };
}
exports.checkMint = checkMint;
const last = (arr) => arr[arr.length - 1];
//# sourceMappingURL=index.js.map