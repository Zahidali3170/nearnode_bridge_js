"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.untrack = exports.track = exports.clear = exports.act = exports.checkStatusAll = exports.getReplacementTransfers = exports.replaceTransfers = exports.remove = exports.decorate = exports.get = exports.getTransferType = exports.setTransferTypes = exports.setBridgeParams = exports.getBridgeParams = exports.getAuroraProvider = exports.getEthProvider = exports.getSignerProvider = exports.setSignerProvider = exports.setAuroraProvider = exports.setNearConnection = exports.setEthProvider = exports.onChange = void 0;
const storage = __importStar(require("./storage"));
const status = __importStar(require("./statuses"));
var storage_1 = require("./storage");
Object.defineProperty(exports, "onChange", { enumerable: true, get: function () { return storage_1.onChange; } });
var utils_1 = require("./utils");
Object.defineProperty(exports, "setEthProvider", { enumerable: true, get: function () { return utils_1.setEthProvider; } });
Object.defineProperty(exports, "setNearConnection", { enumerable: true, get: function () { return utils_1.setNearConnection; } });
Object.defineProperty(exports, "setAuroraProvider", { enumerable: true, get: function () { return utils_1.setAuroraProvider; } });
Object.defineProperty(exports, "setSignerProvider", { enumerable: true, get: function () { return utils_1.setSignerProvider; } });
Object.defineProperty(exports, "getSignerProvider", { enumerable: true, get: function () { return utils_1.getSignerProvider; } });
Object.defineProperty(exports, "getEthProvider", { enumerable: true, get: function () { return utils_1.getEthProvider; } });
Object.defineProperty(exports, "getAuroraProvider", { enumerable: true, get: function () { return utils_1.getAuroraProvider; } });
Object.defineProperty(exports, "getBridgeParams", { enumerable: true, get: function () { return utils_1.getBridgeParams; } });
Object.defineProperty(exports, "setBridgeParams", { enumerable: true, get: function () { return utils_1.setBridgeParams; } });
let customTransferTypes = {};
function setTransferTypes(newTransferTypes) {
    customTransferTypes = newTransferTypes;
    return customTransferTypes;
}
exports.setTransferTypes = setTransferTypes;
function getCustomTransferType(transfer) {
    return customTransferTypes[transfer.type];
}
/**
 * Get the connector library for the given transfer's type
 * @param transfer Transfer object
 */
function getTransferType(transfer) {
    // TODO: find a way to `require(transfer.type)`
    const customTransferType = getCustomTransferType(transfer);
    if (customTransferType)
        return customTransferType;
    try {
        switch (transfer.type) {
            case '@near-eth/nep141-erc20/natural-erc20/sendToNear':
                return require('@near-eth/nep141-erc20/dist/natural-erc20/sendToNear');
            case '@near-eth/nep141-erc20/bridged-nep141/sendToEthereum':
                return require('@near-eth/nep141-erc20/dist/bridged-nep141/sendToEthereum');
            case '@near-eth/near-ether/natural-near/sendToEthereum':
                return require('@near-eth/near-ether/dist/natural-near/sendToEthereum');
            case '@near-eth/near-ether/bridged-near/sendToNear':
                return require('@near-eth/near-ether/dist/bridged-near/sendToNear');
            case '@near-eth/near-ether/natural-ether/sendToNear':
                return require('@near-eth/near-ether/dist/natural-ether/sendToNear');
            case '@near-eth/near-ether/bridged-ether/sendToEthereum':
                return require('@near-eth/near-ether/dist/bridged-ether/sendToEthereum');
            case '@near-eth/aurora-erc20/natural-erc20/sendToAurora':
                return require('@near-eth/aurora-erc20/dist/natural-erc20/sendToAurora');
            case '@near-eth/aurora-erc20/bridged-erc20/sendToEthereum':
                return require('@near-eth/aurora-erc20/dist/bridged-erc20/sendToEthereum');
            case '@near-eth/aurora-ether/natural-ether/sendToAurora':
                return require('@near-eth/aurora-ether/dist/natural-ether/sendToAurora');
            case '@near-eth/aurora-ether/bridged-ether/sendToEthereum':
                return require('@near-eth/aurora-ether/dist/bridged-ether/sendToEthereum');
            case '@near-eth/aurora-nep141/natural-nep141/sendToAurora':
                return require('@near-eth/aurora-nep141/dist/natural-nep141/sendToAurora');
            case '@near-eth/aurora-nep141/bridged-erc20/sendToNear':
                return require('@near-eth/aurora-nep141/dist/bridged-erc20/sendToNear');
            case '@near-eth/aurora-nep141/bridged-ether/sendToNear':
                return require('@near-eth/aurora-nep141/dist/bridged-ether/sendToNear');
            default:
                throw new Error(`Unregistered library for transfer with type=${transfer.type}`);
        }
    }
    catch (depLoadError) {
        console.error(depLoadError);
        throw new Error(`Can't find library for transfer with type=${transfer.type}`);
    }
}
exports.getTransferType = getTransferType;
/**
 * Return a list of transfers
 *
 * @param {object} params Object of options
 * @param params.filter function Optional filter function
 *
 * @example
 *
 *     import { get } from '@near-eth/client'
 *     import { IN_PROGRESS, ACTION_NEEDED } from '@near-eth/client/dist/statuses'
 *     const inFlight = await get({
 *       filter: t => [IN_PROGRESS, ACTION_NEEDED].includes(t.status)
 *     })
 *
 * @returns array of transfers
 */
function get({ filter } = {}) {
    let transfers = storage.getAll();
    if (filter !== undefined)
        transfers = transfers.filter(filter);
    return transfers;
}
exports.get = get;
/*
 * Decorate a transfer with human- and app-friendly attributes.
 *
 * For storage efficiency, raw transfers don't include various attributes. This
 * returns a new object with all original attributes of provided `transfer`,
 * and also adds:
 *
 * - sourceNetwork: either 'ethereum' or 'near'
 * - destinationNetwork: either 'near' or 'ethereum'
 * - error: if status === 'failed', gets set to most recent error encountered
 *     by transfer (raw transfer has `errors` key which stores all errors
 *     encountered throughout life of transfer)
 * - steps: array, with each entry of the form `{ key: String, status:
 *     'pending' | 'complete' | 'failed', description: i18n'd String }`
 * - statusMessage: i18n'd present-tense version of in-progress step, or
 *     "Failed" if transfer.status === 'failed' (check transfer.error for error
 *     message)
 * - callToAction: something like 'Mint' or 'Confirm'; only added if
 *     transfer.status === 'action-needed'
 *
 * If you provide no `locale` or one unsupported by the underlying transfer
 * type, the transfer type's first locale will be used.
 */
function decorate(transfer, { locale } = {}) {
    const type = getTransferType(transfer);
    // @ts-expect-error
    let localized = type.i18n[locale];
    if (localized === undefined) {
        const availableLocales = Object.keys(type.i18n);
        const fallback = availableLocales[0];
        if (fallback !== undefined && locale !== undefined) {
            console.warn(`Requested locale ${locale} not available for ${transfer.type}. Available locales: \n\n  • ${availableLocales.join('\n  • ')}\n\nFalling back to ${fallback}`);
        }
        // @ts-expect-error
        localized = type.i18n[fallback];
    }
    let error;
    if (transfer.status === status.FAILED) {
        error = transfer.errors[transfer.errors.length - 1];
    }
    let steps;
    let statusMessage;
    let callToAction;
    if (localized !== undefined) {
        steps = localized.steps(transfer);
        statusMessage = localized.statusMessage(transfer);
        callToAction = localized.callToAction(transfer);
    }
    else {
        steps = [];
        statusMessage = `transfer with type=${transfer.type} has no defined i18n settings; cannot decorate it`;
    }
    return {
        ...transfer,
        sourceNetwork: type.SOURCE_NETWORK,
        destinationNetwork: type.DESTINATION_NETWORK,
        error,
        steps,
        statusMessage,
        callToAction
    };
}
exports.decorate = decorate;
const transfersToRemove = [];
/**
 * Record a transfer to be removed at the next status check.
 * This remove request will not be processed immediatly (at the next checkStatus loop)
 * so apps may want to manually hide the transfer until it actually gets removed from storage.
 * @param transferId
 */
function remove(transferId) {
    transfersToRemove.push(transferId);
}
exports.remove = remove;
/**
 * Process all pending transfer removal requests
 */
async function checkPendingTransferRemovals() {
    await Promise.all(transfersToRemove.map(async (transferId) => await storage.clear(transferId)));
    transfersToRemove.splice(0, transfersToRemove.length);
}
let replacementTransfers = [];
function replaceTransfers(transfers) {
    replacementTransfers = transfers;
}
exports.replaceTransfers = replaceTransfers;
function getReplacementTransfers() {
    return replacementTransfers;
}
exports.getReplacementTransfers = getReplacementTransfers;
/**
 * Replace all transfers with the replacementTransfers
 */
async function checkPendingTransferSync() {
    if (replacementTransfers.length === 0)
        return;
    console.log('Replacing local transfers with: ', replacementTransfers);
    const transfers = {};
    replacementTransfers.forEach(transfer => {
        transfers[transfer.id] = transfer;
    });
    await storage.replaceAll(transfers);
    replacementTransfers = [];
}
/*
 * Check statuses of all inProgress transfers, and update them accordingly.
 *
 * Can provide a `loop` frequency, in milliseconds, to call repeatedly while
 * inProgress transfers remain
 */
async function checkStatusAll({ loop } = { loop: undefined }) {
    if (loop !== undefined && !Number.isInteger(loop)) {
        throw new Error('`loop` must be frequency, in milliseconds');
    }
    await checkPendingTransferRemovals();
    await checkPendingTransferSync();
    const inProgress = await get({
        filter: t => t.status === status.IN_PROGRESS
    });
    // Check & update statuses for all in parallel
    await Promise.all(inProgress.map(async (t) => await checkStatus(t.id)));
    // loop, if told to loop
    if (loop !== undefined) {
        window.setTimeout(() => { checkStatusAll({ loop }).catch(console.error); }, loop);
    }
}
exports.checkStatusAll = checkStatusAll;
/*
 * Act on a transfer! That is, start whatever comes next.
 *
 * If a transfer step requires user confirmation before proceeding, this gets
 * called when the user confirms they're ready. Whatever next action is
 * appropriate for the transfer with given id, this will take it.
 *
 * If the transfer failed, this will retry it.
 */
async function act(id) {
    const transfer = storage.get(id);
    if (!transfer) {
        throw new Error(`Cannot find and act on transfer with id ${id}`);
    }
    if (![status.FAILED, status.ACTION_NEEDED].includes(transfer.status)) {
        console.warn('No action needed for transfer with status', transfer.status);
        return;
    }
    const type = getTransferType(transfer);
    try {
        await storage.update(await type.act(transfer));
    }
    catch (error) {
        await storage.update(transfer, {
            status: status.FAILED,
            errors: [...transfer.errors, error.message]
        });
        throw error;
    }
}
exports.act = act;
/**
 * Clear a transfer from localStorage
 */
async function clear(id) {
    await storage.clear(id);
}
exports.clear = clear;
/**
 * Add a new transfer to the set of cached local transfers. Transfer will
 * be given a chronologically-ordered id.
 *
 * @param transfer {@link UnsavedTransfer} a transfer with no 'id'
 *
 * @returns {@link Transfer} transfer with an 'id'
 */
async function track(transferRaw) {
    const id = Math.random().toString().slice(2);
    const transfer = { id, ...transferRaw };
    await storage.add(transfer);
    return transfer;
}
exports.track = track;
/**
 * Delete a transfer from the set of cached local transfers.
 * Unlike `remove` which removes at the next checkStatus loop, untrack
 * returns when the transfer is removed.
 *
 * @param transferId
 */
async function untrack(transferId) {
    const transfer = storage.get(transferId);
    if (!transfer) {
        console.warn(`Transfer not tracked: ${transferId}`);
        return;
    }
    if (transfer.status !== status.IN_PROGRESS) {
        // IN-PROGRESS transfers should be cleared by checkStatus
        await storage.clear(transferId);
    }
    else {
        remove(transferId);
        while (transfersToRemove.length !== 0) {
            console.log('waiting ', transfersToRemove);
            // Wait for checkStatus to remove the transfer
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }
}
exports.untrack = untrack;
// Check the status of a single transfer.
async function checkStatus(id) {
    let transfer = storage.get(id);
    if (!transfer) {
        throw new Error(`Cannot find and act on transfer with id ${id}`);
    }
    const type = getTransferType(transfer);
    // only in-progress transfers need to be checked on
    if (transfer.status === status.IN_PROGRESS) {
        try {
            transfer = await type.checkStatus(transfer);
            await storage.update(transfer);
        }
        catch (e) {
            console.error(e);
        }
    }
}
//# sourceMappingURL=index.js.map