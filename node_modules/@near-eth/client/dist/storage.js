"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onChange = exports.replaceAll = exports.clear = exports.update = exports.add = exports.get = exports.getAll = void 0;
const onChangeFns = [];
/**
 * Get raw transfers object from localStorage
 * @param key localStorage key
 */
function localStorageGet(key) {
    try {
        const serializedState = localStorage.getItem(key);
        if (serializedState === null) {
            return {};
        }
        return JSON.parse(serializedState);
    }
    catch (err) {
        return {};
    }
}
/**
 * Set raw transfers object in localStorage
 * @param key localStorage key
 * @param state Raw transfers object
 */
async function localStorageSet(key, state) {
    if (!key || !state) {
        throw new Error('expected two arguments, only got one');
    }
    const serializedState = JSON.stringify(state);
    localStorage.setItem(key, serializedState);
    await Promise.all(onChangeFns.map(fn => fn()));
}
const STORAGE_KEY = 'rainbow-bridge-transfers';
/**
 * Get all transfers object
 */
function getAllRaw() {
    return localStorageGet(STORAGE_KEY);
}
/**
 * Get raw transfers, stored in localStorage as an object indexed by keys
 * Default sort: descending by ID, which corresponds with time created
 */
function getAll() {
    const raw = getAllRaw();
    return Object.keys(raw).sort((a, b) => b < a ? -1 : 1).map(id => raw[id]);
}
exports.getAll = getAll;
/**
 * Get a transfer from, localStorage
 * @param id Transfer id
 */
function get(id) {
    if (!id)
        throw new Error('must provide ID to fetch a single transfer');
    return getAllRaw()[id];
}
exports.get = get;
/**
 * Add a transfer to localStorage transfers
 * @param transfer Transfer to record
 */
async function add(transfer) {
    await localStorageSet(STORAGE_KEY, {
        ...getAllRaw(),
        [transfer.id]: transfer
    });
}
exports.add = add;
/**
 * Update a given transfer in localStorage, returning a new object with the
 * updated version
 * @param transfer Transfer to update
 * @param withData Data to update the transfer with
 */
async function update(transfer, withData = {}) {
    if (!transfer.id) {
        throw new Error('Cannot update transfer with no ID');
    }
    const updatedTransfer = { ...transfer, ...withData };
    // TODO: only update if !deepEqual(get(transfer.id), updatedTransfer)
    await localStorageSet(STORAGE_KEY, {
        ...getAllRaw(),
        [transfer.id]: updatedTransfer
    });
    return updatedTransfer;
}
exports.update = update;
/**
 * Clear a transfer from localStorage
 * @param id Transfer if to delete
 */
async function clear(id) {
    const transfers = getAllRaw();
    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    delete transfers[id];
    await localStorageSet(STORAGE_KEY, transfers);
}
exports.clear = clear;
async function replaceAll(transfers) {
    await localStorageSet(STORAGE_KEY, transfers);
    return transfers;
}
exports.replaceAll = replaceAll;
/**
 * Add a function to be called any time the data in storage is updated
 * @param fn Function to add
 */
function onChange(fn) {
    onChangeFns.push(fn);
}
exports.onChange = onChange;
//# sourceMappingURL=storage.js.map