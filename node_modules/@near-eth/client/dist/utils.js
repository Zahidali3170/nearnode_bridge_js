"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setBridgeParams = exports.getBridgeParams = exports.formatLargeNum = exports.nearAuthedAgainst = exports.getNearAccount = exports.getSignerProvider = exports.getAuroraProvider = exports.getEthProvider = exports.setNearConnection = exports.setSignerProvider = exports.setAuroraProvider = exports.setEthProvider = void 0;
const decimal_js_1 = require("decimal.js");
let ethProvider;
let nearConnection;
let auroraProvider;
let signerProvider;
let bridgeParams;
/**
 * Set ethProvider
 *
 * This must be called by apps that use @near-eth/client before performing any
 * transfer operations with @near-eth/client itself or with connector libraries
 * such as @near-eth/nep141-erc20.
 *
 * Example:
 *
 *     import { ethers } from 'ethers'
 *     import { setEthProvider } from '@near-eth/client'
 *     setEthProvider(new ethers.providers.JsonRpcProvider(url))
 *
 * @param provider Ethereum Provider
 *
 * @returns `provider`
 */
function setEthProvider(provider) {
    ethProvider = provider;
    // TODO: verify provider meets expectations
    return ethProvider;
}
exports.setEthProvider = setEthProvider;
/**
 * Set auroraProvider
 *
 * This must be called by apps that use @near-eth/client before performing any
 * transfer operations with @near-eth/client itself or with connector libraries
 * such as @near-eth/nep141-erc20.
 *
 * Example:
 *
 *     import { ethers } from 'ethers'
 *     import { setAuroraProvider } from '@near-eth/client'
 *     setAuroraProvider(new ethers.providers.JsonRpcProvider(url))
 *
 * @param provider Aurora Provider
 *
 * @returns `provider`
 */
function setAuroraProvider(provider) {
    auroraProvider = provider;
    // TODO: verify provider meets expectations
    return auroraProvider;
}
exports.setAuroraProvider = setAuroraProvider;
/**
 * Set signerProvider
 *
 * This must be called by apps that use @near-eth/client before performing any
 * transfer operations with @near-eth/client itself or with connector libraries
 * such as @near-eth/nep141-erc20.
 *
 * Example:
 *
 *     import { ethers } from 'ethers'
 *     import { setSignerProvider } from '@near-eth/client'
 *     setSignerProvider(new ethers.providers.Web3Provider(window.ethereum, 'any'))
 *     // use 'any' to allow switching networks
 *
 * @param provider Signer Provider
 *
 * @returns `provider`
 */
function setSignerProvider(provider) {
    signerProvider = provider;
    // TODO: verify provider meets expectations
    return signerProvider;
}
exports.setSignerProvider = setSignerProvider;
/**
 * Set nearConnection
 *
 * This must be called by apps that use @near-eth/client before performing any
 * transfer operations with @near-eth/client itself or with connector libraries
 * such as @near-eth/nep141-erc20.
 *
 * Example:
 *
 *     import { Near, WalletConnection } from 'near-api-js'
 *     import { config, setNearConnection } from '@near-eth/client'
 *
 *     setNearConnection(new WalletConnection(
 *       new Near(config.ropsten.near)
 *     ))
 *
 * @param connection WalletConnection instance from near-api-js
 *
 * @returns `connection`
 */
function setNearConnection(connection) {
    nearConnection = connection;
    // TODO: verify connection meets expectations
    return nearConnection;
}
exports.setNearConnection = setNearConnection;
/**
 * Get ethProvider
 *
 * Internal function, only expected to be used by @near-eth/nep141-erc20 and
 * other connector libraries that interoperate with @near-eth/client. If you
 * are an app developer, you can ignore this function.
 *
 * @returns an Ethereum Provider for use with ethers.js
 */
function getEthProvider() {
    return ethProvider;
}
exports.getEthProvider = getEthProvider;
function getAuroraProvider() {
    return auroraProvider;
}
exports.getAuroraProvider = getAuroraProvider;
function getSignerProvider() {
    return signerProvider;
}
exports.getSignerProvider = getSignerProvider;
/**
 * Get NEAR Account for the nearConnection set by `setNearConnection`
 *
 * Internal function, only expected to be used by @near-eth/nep141-erc20 and
 * other connector libraries that interoperate with @near-eth/client. If you
 * are an app developer, you can ignore this function.
 *
 * Ensures that app called `setNearConnection`
 *
 * If `authAgainst` supplied and user is not signed in, will redirect user to
 * NEAR Wallet to sign in against `authAgainst` contract.
 *
 * If provided `strict: true`, will ENSURE that user is signed in against
 * `authAgainst` contract, and not just any contract address.
 *
 * @param params Object with named arguments
 * @param params.authAgainst [undefined] string (optional) The address of a NEAR contract
 *   to authenticate against. If provided, will trigger a page redirect to NEAR
 *   Wallet if the user is not authenticated against ANY contract, whether this
 *   contract or not.
 * @param params.strict [false] boolean (optional) Will trigger a page redirect to NEAR
 *   Wallet if the user is not authenticated against the specific contract
 *   provided in `authAgainst`.
 *
 * @returns WalletAccount a NEAR account object, when it doesn't trigger a page redirect.
 */
async function getNearAccount({ authAgainst, strict = false } = { authAgainst: undefined, strict: false }) {
    if (!nearConnection) {
        throw new Error('Must `setNearConnection(new WalletConnection(near))` prior to calling anything from `@near-eth/client` or connector libraries');
    }
    if (!authAgainst)
        return nearConnection.account();
    if (!nearConnection.getAccountId()) {
        await nearConnection.requestSignIn(authAgainst);
    }
    if (strict && !(await nearAuthedAgainst(authAgainst))) {
        nearConnection.signOut();
        await nearConnection.requestSignIn(authAgainst);
    }
    return nearConnection.account();
}
exports.getNearAccount = getNearAccount;
/**
 * Check that user is authenticated against the given `contract`.
 *
 * Put another way, make sure that current browser session has a FunctionCall
 * Access Key that allows it to call the given `contract` on behalf of the
 * current user.
 *
 * @param contract The address of a NEAR contract
 * @returns boolean True if the user is authenticated against this contract.
 */
async function nearAuthedAgainst(contract) {
    if (!contract) {
        throw new Error(`nearAuthedAgainst expects a valid NEAR contract address.
      Got: \`${contract}\``);
    }
    if (!nearConnection.getAccountId())
        return false;
    const { accessKey } = await nearConnection.account().findAccessKey(contract, []);
    // TODO: this logic may break with FullAccess keys
    const authedAgainst = accessKey === null || accessKey === void 0 ? void 0 : accessKey.accessKey.permission.FunctionCall.receiver_id;
    return authedAgainst === contract;
}
exports.nearAuthedAgainst = nearAuthedAgainst;
function formatLargeNum(n, decimals = 18) {
    // decimals defaults to 18 for old transfers in state that didn't record transfer.decimals
    if (!n) {
        return new decimal_js_1.Decimal(0);
    }
    return new decimal_js_1.Decimal(n).dividedBy(10 ** decimals);
}
exports.formatLargeNum = formatLargeNum;
/**
 * Get bridgeParams
 *
 * Internal function, only expected to be used by @near-eth/nep141-erc20 and
 * other connector libraries that interoperate with @near-eth/client. If you
 * are an app developer, you can ignore this function.
 *
 * @returns Bridge parameters
 */
function getBridgeParams() {
    return bridgeParams;
}
exports.getBridgeParams = getBridgeParams;
/**
 * Set bridge parameters (contract addresses, abi...)
 *
 * This should be called by apps that use @near-eth/client before performing any
 * transfer operations with @near-eth/client itself or with connector libraries
 * such as @near-eth/nep141-erc20.
 * Otherwise connector libraries can also be used without bridgeParams by specifying the required
 * arguments in `options`.
 *
 * Example: bridge parameters for @near-eth/nep141-erc20
 *
 *  setBridgeParams({
 *    nearEventRelayerMargin: 10, // 10 blocks margin for the Event relayer to finalize the transfer
 *    sendToNearSyncInterval: 20000, // check light client sync every 20sec
 *    sendToEthereumSyncInterval: 60000, // check light client sync every 60sec
 *    ethChainId: 1, // mainnet
 *    erc20Abi: process.env.ethErc20AbiText, // Standard ERC-20 ABI
 *    erc20LockerAddress: '0x23ddd3e3692d1861ed57ede224608875809e127f',
 *    erc20LockerAbi: process.env.ethLockerAbiText,
 *    nep141Factory: 'factory.bridge.near',
 *    ethClientAddress: '0x0151568af92125fb289f1dd81d9d8f7484efc362',
 *    ethClientAbi: process.env.ethNearOnEthClientAbiText,
 *    nearClientAccount: 'client.bridge.near'
 *  })
 *
 * @param params Object containing bridge parameters
 * @returns `params`
 */
function setBridgeParams(params) {
    bridgeParams = params;
    return bridgeParams;
}
exports.setBridgeParams = setBridgeParams;
//# sourceMappingURL=utils.js.map